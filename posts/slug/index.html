<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Bezier curve in Unity: Bounding boxes | Snoozetime's webpage</title>
<link href="../../assets/css/bootstrap.min.css" rel="stylesheet" type="text/css">
<link href="../../assets/css/html4css1.css" rel="stylesheet" type="text/css">
<link href="../../assets/css/nikola_rst.css" rel="stylesheet" type="text/css">
<link href="../../assets/css/code.css" rel="stylesheet" type="text/css">
<link href="../../assets/css/colorbox.css" rel="stylesheet" type="text/css">
<link href="../../assets/css/theme.css" rel="stylesheet" type="text/css">
<link href="../../assets/css/custom.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#400000">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" href="../../rss.xml">
<link rel="canonical" href="http://snoozetime.github.io/posts/slug/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><link href="../../assets/css/ipython.min.css" rel="stylesheet" type="text/css">
<link href="../../assets/css/nikola_ipython.css" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="assets/css/typeplate.css">
<link rel="stylesheet" media="screen" href="http://openfontlibrary.org/face/railway-sans" type="text/css">
<meta name="author" content="Snoozetime">
<link rel="prev" href="../random-pictures-in-japan-1/" title="Random pictures in Japan 1" type="text/html">
<meta property="og:site_name" content="Snoozetime's webpage">
<meta property="og:title" content="Bezier curve in Unity: Bounding boxes">
<meta property="og:url" content="http://snoozetime.github.io/posts/slug/">
<meta property="og:description" content="Introduction








Instead of the common FPS/RPG/Platformer, for some reason I decide to create a clone of the old micromachine,
in particular the elimination mode when players are eliminated when t">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2018-05-22T00:00:00+09:00">
<meta property="article:tag" content="2d">
<meta property="article:tag" content="bezier">
<meta property="article:tag" content="gamedev">
<meta property="article:tag" content="mathjax">
<meta property="article:tag" content="unity">
</head>
<body>
<!-- Menubar -->

<nav class="navbar navbar-default navbar-fixed-top" role="navigation"><div class="container">
    <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="http://snoozetime.github.io/">Snoozetime's webpage</a>
    </div>
    <div class="collapse navbar-collapse">
        <ul class="nav navbar-nav">
<li>
<a href="../../index.html">Home</a>
                </li>
<li>
<a href="../../archive.html">Archives</a>
                </li>
<li>
<a href="../../categories/index.html">Tags</a>
                </li>
<li>
<a href="../../rss.xml">RSS</a>

        </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<!--Add Links to social media sites --><!-- pass --><li>
    <a href="index.org" id="sourcelink">Source</a>
    </li>

        </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
</nav><!-- End of Menubar --><div class="container">
  <!--Body content-->
  <div class="row">
      
      
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">Bezier curve in Unity: Bounding boxes</a></h1>

        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                    Snoozetime
            </span></p>
            <p class="dateline"><a href="." rel="bookmark"><time class="published dt-published" datetime="2018-05-22T00:00:00+09:00" itemprop="datePublished" title="2018-05-22 00:00">2018-05-22 00:00</time></a></p>
                <p class="commentline">
        
    <a href="#disqus_thread" data-disqus-identifier="cache/posts/bezier-curve-bounding-box.html">Comments</a>


            
        </p>
<p class="sourceline"><a href="index.org" class="sourcelink">Source</a></p>

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Introduction</h2>
<div class="outline-text-2" id="text-1">

<div class="figure">
<p><img src="../../images/micromachine.jpg" alt="micromachine.jpg"></p>
</div>

<p>
Instead of the common FPS/RPG/Platformer, for some reason I decide to create a clone of the old micromachine,
in particular the elimination mode when players are eliminated when they are too far away from the first player.
</p>

<p>
As the game was creating itself in my head, I stumbled against a mathematical obstacle in the first week
of prototyping. How to determine which player is the first? How to determinate what path the AI should
follow.
</p>

<p>
It turns out that part of the answer is to represent tracks as a curve, and Bezier curves are used in a bunch of
applications from photoshop to font creation. To find out what player is first, I would just have
to calculate the position of all pilots on the tracks.
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Some reading before getting started</h2>
<div class="outline-text-2" id="text-2">
<p>
This article will be introducing a bit a linear algebra. In particular, we will apply translation and
rotation to our vectors. Also, we need to find the roots of a quadratic equation. The maths are not
too complicated but feel free to read the following links beforehand:
</p>
<ul class="org-ul">
<li>
<a href="https://en.wikipedia.org/wiki/Quadratic_equation">Wikipedia article on finding the roots of a quadratic formula</a>
</li>
<li>
<a href="http://planning.cs.uiuc.edu/node97.html">Description of translation, rotation and their combinaison</a>
</li>
</ul>
<p>
This article builds on an existing article which can be found here: <a href="https://catlikecoding.com/unity/tutorials/curves-and-splines/">https://catlikecoding.com/unity/tutorials/curves-and-splines/</a>
It shows how to implement a Bezier curve in Unity, showing at the same time how editor scripts work.
</p>

<p>
The last resource is an ebook called "A primer on Bezier". It can be found <a href="https://pomax.github.io/bezierinfo/">here.</a>
This ebook contains all you need to know about Bezier curves, theory and pseudocode included.
</p>


<div class="figure">
<p><img src="../../images/bezier_initial.png" alt="bezier_initial.png"></p>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Bounding box</h2>
<div class="outline-text-2" id="text-3">
<p>
Bounding box are useful. In my use case, I want to find the closest point to the spline so bounding boxes
will help determine what bezier curve I should select to do the calculation!
</p>

<p>
The way to find the bounding box is to get the minimim/maximum along the x and y axis and create the boxes
from (x<sub>min</sub>, y<sub>min</sub>), (x<sub>min</sub>, y<sub>max</sub>), (x<sub>max</sub>, y<sub>min</sub>), (x<sub>max</sub>, y<sub>max</sub>).
</p>

<p>
However, this has the tendency to create large bounding boxes so we can get tighter boxes by aligning them
along our curve. (<a href="https://pomax.github.io/bezierinfo/#boundingbox">Part 17 - Bounding box</a>)
</p>
</div>

<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">Beforehand, define the curve</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Curve is such as
</p>
\begin{equation}
B(t) = (1-t)^3P_0 + 3(1-t)^2tP_1 + 3(1-t)t^2P_2 + t^3P_3
\end{equation}

<p>
where \(P_0, P_1, P_2, P_3\) are the control points of the curve, in global coordinates.
</p>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">Align the curve on an axis.</h3>
<div class="outline-text-3" id="text-3-2">
<p>
To align the curve, we first need to apply a translation T to the first point of the curve in order to place it
on the origin (0, 0). We have \(T = -P_0\).
</p>

<div class="highlight"><pre><span></span>// Translation such as p0 is at (0,0)
Vector2 [] translatedVector = new Vector2[] {
    p0 - p0,
    p1 - p0,
    p2 - p0,
    p3 - p0
};
</pre></div>

<p>
Then, we need to apply the rotation so that \(P_3\) is on the x-axis. Given x and y the coordinates of \(P_3\), x' and y'
the coordinates after rotation \(\theta\), we have the equations:
</p>

\begin{equation}
x' = xcos(theta) - ysin(theta)

y' = ycos(theta) + x sin(theta)
\end{equation}

<p>
<a href="https://www.siggraph.org/education/materials/HyperGraph/modeling/mod_tran/2drota.htm">Don't take my word for granted :)</a>
</p>

<div class="highlight"><pre><span></span>private static Vector2 Rotate(Vector2 p, float theta) {
    // x' = x cos f - y sin f
    // y' = y cos f + x sin f
    float xp = p.x * Mathf.Cos(theta) - p.y * Mathf.Sin(theta);
    float yp = p.y * Mathf.Cos(theta) + p.x * Mathf.Sin(theta);

    return new Vector2(xp, yp);
}
</pre></div>

<p>
We find theta such as \(y' = 0\).
</p>
\begin{equation}
\theta = atan(-y/x)
\end{equation}

<div class="highlight"><pre><span></span>// Find rotation such as translatedVector[3] is on the axis
Vector2 pp3 = translatedVector[3];
float theta = Mathf.Atan(-pp3.y/pp3.x);
</pre></div>

<p>
Just for fun, let's draw the Bezier curve after rotation.
</p>

<div class="highlight"><pre><span></span>public static Vector2[] GetAlignedCurve(Vector2 p0, Vector2 p1, Vector2 p2, Vector2 p3) {

    // Translation such as p0 is at (0,0)
    Vector2 [] translatedVector = new Vector2[] {
	p0 - p0,
	p1 - p0,
	p2 - p0,
	p3 - p0
    };

    // Find rotation such as translatedVector[3] is on the axis
    Vector2 pp3 = translatedVector[3];
    float theta = Mathf.Atan(-pp3.y/pp3.x);

    // Now calculate new vectors.
    return new Vector2[] {
	Rotate(p0 - p0, theta),
	Rotate(p1 - p0, theta),
	Rotate(p2 - p0, theta),
	Rotate(p3 - p0, theta)
    };
}
</pre></div>

<p>
When adding the aligned curve to the editor script, we get the following.
</p>


<div class="figure">
<p><img src="../../images/aligned_bezier.png" alt="aligned_bezier.png"></p>
</div>
</div>
</div>

<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">Find the bounding box for the aligned curve</h3>
<div class="outline-text-3" id="text-3-3">
<p>
Once we have our aligned curve, we need to find its bounding box. To do so, we need to calculate the roots of the
curve for x and y in order to get the minimum and maximum on the axis for t between 0 and 1.
</p>

<p>
To get an idea about why we want the minimum and maximum of a curve, please refer to my amazing drawing.
<img src="../../images/bounding_box.png" alt="bounding_box.png"></p>

<p>
In this piece of art, the maximum and minimum of y are located on the curve. For x however, only the
minimum x is located on the curve. The maximum is one of our control point. This is why we absolutely
have to include the first and last control points when we want to find the minimum and maximum on each
axis.
</p>

<p>
For a quadratic or cubic Bezier curve, it is very easy to find the minimum and maximum for each axis.
The way to do it is to calculate the derivate of the curve, and find the t values for which this
derivative is 0. These values are called the roots of the curve for the x or y axis. The Wikipedia
article at the top of the blog article explains it more deeply.
</p>

<p>
After deriving the Bezier equation and simplifying it a bit, we obtain:
</p>
\begin{equation}
3 (-x_{p_0} + 3x_{p_1} - 3x_{p_2} + x_{p_3})t^2 + 6(x_{p_0} - 2x_{p_1} + x_{p_2})t + 3(x_{p_1} - x_{p_0}) = 0
\end{equation}

<p>
Where \(x_{p_i}\) is the x coordinate of the point i. There is the same equation for y. Now that
we have reduce our equation to a simple quadratic equation, the solution is textbook.
</p>

\begin{equation}
a = 3(-x_{p_0} + 3x_{p_1} - 3x_{p_2} + x_{p_3})
\end{equation}

\begin{equation}
b = 6(x_{p_0} - 2x_{p_1} + x_{p_2})
\end{equation}

\begin{equation}
c = 3(x_{p_1} - x_{p_0})
\end{equation}

\begin{equation}
\Delta = b^2 - 4 ac
\end{equation}

<p>
\(\Delta\) (Delta) is the discriminant. We can find imaginary roots (that cannot be represented in our
2D space) when delta is negative, so here we are just interested about the real roots, meaning when
\(\Delta &gt;= 0\).
</p>

<p>
The two roots (which can be only one is the discriminant is 0) for the axis x are:
</p>

\begin{equation}
t_1 = \frac{-b - \sqrt{\Delta}}{4ac}
\end{equation}

\begin{equation}
t_2 = \frac{-b + \sqrt{\Delta}}{4ac}
\end{equation}

<p>
Notice that when \(\Delta\) is 0, \(t_1\) and \(t_2\) are the same. For our Bezier curve, we only care about
parameter between 0 and 1 so the roots might not be usable. In C#, there is not much complexity. Just
write down the last equations and filter the values.
</p>

<div class="highlight"><pre><span></span>/*
  Find the roots of a cubic bezier curve in order to find minimum and maximum
 */
private static List&lt;float&gt; FindRoots(Vector2 p0, Vector2 p1, Vector2 p2, Vector2 p3) {
    Vector2 a = 3 * (-p0 + 3*p1 - 3*p2 + p3);
    Vector2 b = 6 * (p0 - 2*p1 + p2);
    Vector2 c = 3 * (p1 - p0);

    List&lt;float&gt; roots = new List&lt;float&gt;();

    // along x
    float discriminantX = b.x * b.x - 4 * a.x * c.x;
    if (discriminantX &lt; 0) {
	// No roots
    } else if (discriminantX == 0) {
	// one real root
	float rootx = (-b.x) / (2 * a.x);
	if (rootx &gt;=0 &amp;&amp; rootx &lt;= 1) {
	    roots.Add(rootx);
	}
    } else if (discriminantX &gt; 0) {
	// Two real roots
	float rootx1 = (-b.x + Mathf.Sqrt(discriminantX)) / (2 * a.x);
	float rootx2 = (-b.x - Mathf.Sqrt(discriminantX)) / (2 * a.x);
	if (rootx1 &gt;=0 &amp;&amp; rootx1 &lt;= 1) {
	    roots.Add(rootx1);
	}
	if (rootx2 &gt;=0 &amp;&amp; rootx2 &lt;= 1) {
	    roots.Add(rootx2);
	}
    }

    // along y
    float discriminantY = b.y * b.y - 4 * a.y * c.y;
    if (discriminantY &lt; 0) {
	// No roots
    } else if (discriminantY == 0) {
	// one real root
	float rooty = (-b.y) / (2 * a.y);
	if (rooty &gt;=0 &amp;&amp; rooty &lt;= 1) {
	    roots.Add(rooty);
	}
    } else if (discriminantY &gt; 0) {
	// Two real roots
	float rooty1 = (-b.y + Mathf.Sqrt(discriminantY)) / (2 * a.y);
	float rooty2 = (-b.y - Mathf.Sqrt(discriminantY)) / (2 * a.y);
	if (rooty1 &gt;=0 &amp;&amp; rooty1 &lt;= 1) {
	    roots.Add(rooty1);
	}
	if (rooty2 &gt;=0 &amp;&amp; rooty2 &lt;= 1) {
	    roots.Add(rooty2);
	}
    }

    return roots;
}
</pre></div>
<p>
(You can even refactor this to do the calculation once! When reading back this code I noticed that
I was a bit lazy here).
</p>


<p>
Now, our minimum and maximum along x and y would be one of the point that has a parameter t, where t
is either a root, 0 or 1.
</p>

<div class="highlight"><pre><span></span>List&lt;float&gt; roots = FindRoots(pa0, pa1, pa2, pa3);


// Initialize min and max with the first point
float min_x = Mathf.Min(pa0.x, pa3.x);
float max_x = Mathf.Max(pa0.x, pa3.x);
float min_y = Mathf.Min(pa0.y, pa3.y);
float max_y = Mathf.Max(pa0.y, pa3.y);

for (int i = 0; i &lt; roots.Count; i++) {
    float param = roots[i];
    Vector2 point = GetPoint(pa0, pa1, pa2, pa3, param);

    if (point.x &gt; max_x) {
	max_x = point.x;
    }

    if (point.x &lt; min_x) {
	min_x = point.x;
    }

    if (point.y &gt; max_y) {
	max_y = point.y;
    }

    if (point.y &lt; min_y) {
	min_y = point.y;
    }
}
</pre></div>

<p>
We have our \(x_min\), \(x_max\), \(y_min\), \(y_max\). This is all we need for drawing the bounding box.
</p>



<div class="figure">
<p><img src="../../images/bounding_box_aligned.png" alt="bounding_box_aligned.png"></p>
</div>
</div>
</div>



<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4">Rotate the box back</h3>
<div class="outline-text-3" id="text-3-4">
<p>
Almost there! At this point, we have the bounding box of the aligned curve. To get the aligned curve,
we applied two transformations to our Bezier curve: first a translation, then a rotation. To get back
to the original curve, you can simply do the inverse! First, rotate the aligned curve by the opposite
of the first rotation (\(-\theta\)), then translate it by the opposite of the first translation (\(-P_0\)).
</p>

<p>
We can do the same with the bounding box, and it should fit our original Bezier curve!
</p>

<p>
With the previous minima and maxima:
</p>
<div class="highlight"><pre><span></span>return new Vector2[] {
    Rotate(new Vector2(min_x, min_y), -theta) + p0,
    Rotate(new Vector2(min_x, max_y), -theta) + p0,
    Rotate(new Vector2(max_x, min_y), -theta) + p0,
    Rotate(new Vector2(max_x, max_y), -theta) + p0,
};
</pre></div>

<p>
Which gives us, at last:
</p>


<div class="figure">
<p><img src="../../images/bounding_box_final.png" alt="bounding_box_final.png"></p>
</div>
</div>
</div>
</div>



<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">What's next?</h2>
<div class="outline-text-2" id="text-4">
<p>
All this to find the bounding boxes of each curve in our Bezier spline! While it looks like a lot of work,
these bounding boxes are really going to help us find the projection of a point on the spline.
</p>

<p>
Instead of having to consider all the spline, now we can just reduce the problem to a list of Bezier curves.
Calculating distance to a box is pretty simple, so we just need to find the closest boxes to our point and
for each curve, finding the closest point. This will be done by an iterative approach (mathematical approach
is out of the question here - spoiler alert), so keep tuned for the next article.
</p>
</div>
</div>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/2d/" rel="tag">2d</a></li>
            <li><a class="tag p-category" href="../../categories/bezier/" rel="tag">bezier</a></li>
            <li><a class="tag p-category" href="../../categories/gamedev/" rel="tag">gamedev</a></li>
            <li><a class="tag p-category" href="../../categories/unity/" rel="tag">unity</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../random-pictures-in-japan-1/" rel="prev" title="Random pictures in Japan 1">Previous post</a>
            </li>
        </ul></nav></aside><section class="comments hidden-print"><h2>Comments</h2>
        
        
        <div id="disqus_thread"></div>
        <script>
        var disqus_shortname ="https-snoozetime-github-io",
            disqus_url="http://snoozetime.github.io/posts/slug/",
        disqus_title="Bezier curve in Unity: Bounding boxes",
        disqus_identifier="cache/posts/bezier-curve-bounding-box.html",
        disqus_config = function () {
            this.language = "en";
        };
        (function() {
            var dsq = document.createElement('script'); dsq.async = true;
            dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
</noscript>
    <a href="https://disqus.com" class="dsq-brlink" rel="nofollow">Comments powered by <span class="logo-disqus">Disqus</span></a>


        </section><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" integrity="sha256-SDRP1VVYu+tgAGKhddBSl5+ezofHKZeI+OzxakbIe/Y=" crossorigin="anonymous"></script><script type="text/x-mathjax-config">
        MathJax.Hub.Config({tex2jax: {inlineMath: [['$latex ','$'], ['\\(','\\)']]}});
        </script></article><script>var disqus_shortname="https-snoozetime-github-io";(function(){var a=document.createElement("script");a.async=true;a.src="https://"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script>
</div>

  <div class="footerbox">
    Contents © 2018         <a href="mailto:benoit.eudier@gmail.com">Snoozetime</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         
    
  </div>
<!--End of body content-->
</div>

            <script src="../../assets/js/jquery.min.js"></script><script src="../../assets/js/bootstrap.min.js"></script><script src="../../assets/js/moment-with-locales.min.js"></script><script src="../../assets/js/fancydates.js"></script><script src="../../assets/js/jquery.colorbox-min.js"></script><!-- Add Jumbotron scroll js --><script type="text/javascript">//<![CDATA[
$(window).load(function(){
  $(window).scroll(function() {
    var scrolledY = $(window).scrollTop();
    $('.jumbotron').css('background-position', 'left ' + ((scrolledY)) + 'px');
  });
});//]]>
</script><script>jQuery("a.image-reference").colorbox({rel:"gal",maxWidth:"100%",maxHeight:"100%",scalePhotos:true});</script><!-- fancy dates --><script>
moment.locale("en");
fancydates(0, "YYYY-MM-DD HH:mm");
</script><!-- end fancy dates --><!-- Abstract hide/show 
<script src"/assets/js/div_toggle.js"></script>
--><script type="text/javascript">
function toggle(showHideDiv, switchTextDiv) {
    var ele = document.getElementById(showHideDiv);
    var text = document.getElementById(switchTextDiv);
    if(ele.style.display == "none") {
        ele.style.display = "block";
        text.innerHTML = "[hide abstract]";
    }
    else {
            ele.style.display = "none";
            text.innerHTML = "[show abstract]";
    }
}
</script>
</body>
</html>
