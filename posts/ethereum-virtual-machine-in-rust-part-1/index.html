<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Ethereum Virtual Machine in Rust - Part 1 | Snoozetime's webpage</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link href="https://fonts.googleapis.com/css?family=Playfair+Display:700,900" rel="stylesheet">
<meta name="theme-color" content="#400000">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" href="../../rss.xml">
<link rel="canonical" href="http://snoozetime.github.io/posts/ethereum-virtual-machine-in-rust-part-1/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Snoozetime">
<link rel="prev" href="../slug/" title="Bezier curve in Unity: Bounding boxes" type="text/html">
<meta property="og:site_name" content="Snoozetime's webpage">
<meta property="og:title" content="Ethereum Virtual Machine in Rust - Part 1">
<meta property="og:url" content="http://snoozetime.github.io/posts/ethereum-virtual-machine-in-rust-part-1/">
<meta property="og:description" content="Welcome to the great series - if everything goes well - about the Ethereum Virtual machine.
Lately I have been growing fond of emulation and cryptocurrency so I decided to take a look
at the inside of">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2018-11-09T13:54:50+09:00">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Header and menu bar -->
<div class="container">
      <header class="blog-header py-3"><div class="row nbb-header align-items-center">
          <div class="col-md-3 col-xs-2 col-sm-2" style="width: auto;">
            <button class="navbar-toggler navbar-light bg-light nbb-navbar-toggler" type="button" data-toggle="collapse" data-target=".bs-nav-collapsible" aria-controls="bs-navbar" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse bs-nav-collapsible bootblog4-search-form-holder">
                
            </div>
        </div>
          <div class="col-md-6 col-xs-10 col-sm-10 bootblog4-brand" style="width: auto;">
            <a class="navbar-brand blog-header-logo text-dark" href="http://snoozetime.github.io/">

            <span id="blog-title">Snoozetime's webpage</span>
        </a>
          </div>
            <div class="col-md-3 justify-content-end align-items-center bs-nav-collapsible collapse flex-collapse bootblog4-right-nav">
            <nav class="navbar navbar-light bg-white"><ul class="navbar-nav bootblog4-right-nav">
<li class="nav-item">
    <a href="index.md" id="sourcelink" class="nav-link">Source</a>
    </li>


                    
            </ul></nav>
</div>
    </div>
</header><nav class="navbar navbar-expand-md navbar-light bg-white static-top"><div class="collapse navbar-collapse bs-nav-collapsible" id="bs-navbar">
            <ul class="navbar-nav nav-fill d-flex w-100">
<li class="nav-item">
<a href="../../index.html" class="nav-link">Home</a>
                </li>
<li class="nav-item">
<a href="../../archive.html" class="nav-link">Archives</a>
                </li>
<li class="nav-item">
<a href="../../categories/index.html" class="nav-link">Tags</a>
                </li>
<li class="nav-item">
<a href="../../rss.xml" class="nav-link">RSS</a>

                
            </li>
</ul>
</div>
<!-- /.navbar-collapse -->
</nav>
</div>

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        
        
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">Ethereum Virtual Machine in Rust - Part 1</a></h1>

        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                    Snoozetime
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2018-11-09T13:54:50+09:00" itemprop="datePublished" title="2018-11-09 13:54">2018-11-09 13:54</time></a>
            </p>
                <p class="commentline">
        
    <a href="#disqus_thread" data-disqus-identifier="cache/posts/ethereum-virtual-machine-in-rust-part-1.html">Comments</a>


            
        </p>
<p class="sourceline"><a href="index.md" class="sourcelink">Source</a></p>

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <div>
<p>Welcome to the great series - if everything goes well - about the Ethereum Virtual machine.
Lately I have been growing fond of emulation and cryptocurrency so I decided to take a look
at the inside of Ethereum: the virtual machine that is executing smart contracts.</p>
<p>And while implementing a fake EVM (Ethereum Virtual Machine) can be a challenge, why not do
it in a language I have absolutely no experience in. After these few lines, I realize the
probabilities I finish this serie of blog post is meager at best.</p>
<p>Anyway let's get started. In this first part I'll talk about compiling a solidity contract
to binary file, and creating a small program to read each instruction.</p>
<h3>Our Amazing smart contract</h3>
<p>Take a look at this beauty.</p>
<pre class="code literal-block"><span></span>pragma solidity ^0.4.0;

contract Addition{

    int public x;

    function add(int a, int b) public {
        x = a + b;
    }
}
</pre>


<p>It's not doing much. Anybody can call <code>add</code> which will just store the addition of its
argument in the ledger. Then anybody can read the value.</p>
<p>Then, run <code>solc --bin-runtime --optimize -o . contract.sol</code> to output the compiled contract  binary code to the current directory.</p>
<p>On my computer, I get:</p>
<blockquote>
<p>608060405260043610603e5763ffffffff7c0100000000000000000000000000000000000000000000000000000000600035041663a5f3c23b81146043575b600080fd5b348015604e57600080fd5b50605b600435602435605d565b005b016000555600a165627a7a723058204ff1427599e28990ab2413948c03501a48ab89d18888ac7d0205c12f443424070029</p>
</blockquote>
<p>By the way, this is an hexadecimal string. This is going to be important when we read it from Rust (https://solidity.readthedocs.io/en/v0.4.21/using-the-compiler.html)</p>
<h3>Reading the binary file</h3>
<p>Rust makes it quite easy to read data from a file.</p>
<pre class="code literal-block"><span></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">prelude</span>::<span class="o">*</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">error</span>::<span class="n">Error</span><span class="p">;</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">run</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">Error</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">filename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"myfilename"</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">f</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">buffer</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">run</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre>


<p>This is going to print the content of our file. Right now, the whole code is loaded in the
string. There might be better way to do it but ultimately the code is always loaded in the RAM
of the EVM. Also, the smart contracts tend to be small so it should be no problem to do it like
that.</p>
<h3>Opcode and Virtual machine execution</h3>
<p>A virtual machine, such as the Java Virtual Machine, will take a set of instructions and execute
them. in Java the set of instruction is in the Java bytecode (https://en.wikipedia.org/wiki/Java_bytecode). In Ethereum, the set of instruction is the content of the binary file we just read. The instruction set is described in the Ethereum Yellow paper, in the appendix. https://ethereum.github.io/yellowpaper/paper.pdf</p>
<p>For example, the value 0x30 corresponds to the ADDRESS instruction (or opcode) and tells the
ethereum VM to get the address of currently executed account. Let's not worry about all the technical terms for now. Just keep in mind that our binary file is a set of instructions, and
each instructions are 8 bits, or 1 byte, long.</p>
<p>Our file content is an hexadecimal string, so we can represent the first bytes as:
<em>0x60</em> <em>0x80</em> <em>0x60</em> <em>0x40</em> <em>0x52</em>
If you look at the specifications, you can convert to a more readable format:
- PUSH one byte to stack: 0x80
- PUSH one byte to stack: 0x40
- STORE one word to memory</p>
<p>Next step in our program is to convert our string to a list of bytes (<code>u8</code> in Rust).</p>
<pre class="code literal-block"><span></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">num</span>::<span class="n">ParseIntError</span><span class="p">;</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">decode</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">ParseIntError</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="mi">0</span><span class="p">..(</span><span class="n">s</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">step_by</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">i</span><span class="o">|</span><span class="w"> </span><span class="kt">u8</span>::<span class="n">from_str_radix</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">..</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="mi">16</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">collect</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre>


<p>It will construct a vector of bytes. Function composition here makes the code very expressive:
- We get an iterator from 0 to the length of our string (excluded)
- We get another iterator that will yield the first iterator elements with a step of 2. (Yield 0, 2, 4, 6... and so on)
- Then, for each index, we apply <code>u8::from_str_radix</code> to the slice [i..i+2] of our input string. This is going to convert the string to a <code>u8</code> integer, base 16. This can panic in case the string does not represent a valid integer base 16 ('P0' would panic)
- We consume the iterators with collect.</p>
<p>Iterators are lazy in Rust, so we need to call collect at the end to consume them. See here for more details: https://doc.rust-lang.org/book/second-edition/ch13-02-iterators.html</p>
<p>The Result trait implements FromIter, so instead of returning <code>Vec&lt;Result&lt;u8, ParseIntError&gt;&gt;</code>, we can return <code>Result&lt;Vec&lt;u8&gt;, ParseIntError&gt;</code>. See also here https://doc.rust-lang.org/std/result/enum.Result.html#method.from_iter</p>
<p>Now we can print our bytes from the files.</p>
<pre class="code literal-block"><span></span><span class="k">fn</span> <span class="nf">run</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">Error</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">filename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"myfilename"</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">f</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">buffer</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">bytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">decode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bytes</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">"0x{:x}"</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre>


<h3>Our simple EVM</h3>
<p>Now that we can read the bytes of our compiled smart contract, let's start the implementation
of the VM. I am just going to show how to print debug information about the instructions in this
part. We are going to iterate over the list of instructions and print what they mean. No stack
or memory involved here :)</p>
<p>The most basic VM will hold the code in memory, and will iterate through it. We could use range-based loop to do the iteration, but you will see later that it won't work nicely with our use case.
For example, not all instructions are only one byte long. Some, such as PUSH3, are 4 bytes long (one byte for the instruction value, and 3 bytes for the value to push to the stack).</p>
<p>For that reason, I am going to keep an index of the current instruction in the code vector. This index is often called pc, for program counter.</p>
<pre class="code literal-block"><span></span><span class="k">struct</span> <span class="nc">Vm</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">code</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="c1">// smart contract code</span>
<span class="w">    </span><span class="n">pc</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="c1">// current instruction</span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Vm</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">new_from_file</span><span class="p">(</span><span class="n">filename</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Vm</span><span class="p">,</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">Error</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">f</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">buffer</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">code</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">decode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">Vm</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">code</span>: <span class="nc">code</span><span class="p">,</span><span class="w"> </span><span class="n">pc</span>: <span class="mi">0</span><span class="p">})</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre>


<p><code>new_from_file</code> will initialize us a new VM. Then, we need a way to model the instruction. I found enumeration in Rust well suited for this as they are very flexible. I also really like
the pattern matching with enumerations.</p>
<p>Let's get started. There are more than an hundred instructions in the EVM instruction set so
I'll just show a few of them.</p>
<pre class="code literal-block"><span></span><span class="k">enum</span> <span class="nc">Opcode</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="n">STOP</span><span class="p">,</span><span class="w"> </span><span class="c1">// 0x00</span>
<span class="w">    </span><span class="n">ADD</span><span class="p">,</span><span class="w"> </span><span class="c1">// 0x01</span>
<span class="w">    </span><span class="n">MUL</span><span class="p">,</span><span class="w"> </span><span class="c1">// 0x02</span>

<span class="w">    </span><span class="n">PUSH1</span><span class="p">(</span><span class="kt">u8</span><span class="p">),</span><span class="w"> </span><span class="c1">// 0x60</span>
<span class="w">    </span><span class="n">PUSH2</span><span class="p">(</span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">),</span><span class="w"> </span><span class="c1">// 0x61</span>

<span class="w">    </span><span class="n">PUSH32</span><span class="p">(</span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">),</span><span class="w"> </span><span class="c1">// 0x7f </span>
<span class="p">}</span><span class="w"></span>
</pre>


<p><code>PUSH1(u8)</code> means that the instruction is made of 2 bytes. First byte is the instruction value, 
second byte is the value to push to the stack. We are going to store this value in the enumeration.</p>
<p>Now that we have our Opcode enumeration, we need to yield opcodes from the list of bytes. This is called decoding. The <code>next</code> function will return the Opcode at the current pc, and then advance pc to the next instruction.</p>
<pre class="code literal-block"><span></span><span class="k">impl</span><span class="w"> </span><span class="n">Vm</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Opcode</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">code</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">pc</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="mh">0x00</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="bp">self</span><span class="p">.</span><span class="n">pc</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="nb">Some</span><span class="p">(</span><span class="n">Opcode</span>::<span class="n">STOP</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="p">},</span><span class="w"></span>
<span class="w">            </span><span class="mh">0x01</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="bp">self</span><span class="p">.</span><span class="n">pc</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="nb">Some</span><span class="p">(</span><span class="n">Opcode</span>::<span class="n">ADD</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="p">},</span><span class="w"></span>
<span class="w">            </span><span class="mh">0x02</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="bp">self</span><span class="p">.</span><span class="n">pc</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="nb">Some</span><span class="p">(</span><span class="n">Opcode</span>::<span class="n">MUL</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="p">},</span><span class="w"></span>
<span class="w">            </span><span class="mh">0x60</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">code</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">pc</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="w">                </span><span class="bp">self</span><span class="p">.</span><span class="n">pc</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="nb">Some</span><span class="p">(</span><span class="n">Opcode</span>::<span class="n">PUSH1</span><span class="p">(</span><span class="n">value</span><span class="p">))</span><span class="w"></span>
<span class="w">            </span><span class="p">},</span><span class="w"></span>
<span class="w">            </span><span class="n">Ox61</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">value0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">code</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">pc</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">value1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">code</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">pc</span><span class="o">+</span><span class="mi">2</span><span class="p">];</span><span class="w"></span>
<span class="w">                </span><span class="bp">self</span><span class="p">.</span><span class="n">pc</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="nb">Some</span><span class="p">(</span><span class="n">Opcode</span>::<span class="n">PUSH2</span><span class="p">(</span><span class="n">value0</span><span class="p">,</span><span class="w"> </span><span class="n">value1</span><span class="p">))</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">pc</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="nb">None</span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre>


<p>Right now, I ignore the error cases (for example, buffer overflow). Rust will panic if I try to
access values with indexes that are larger that the size of the vector. Also, the code is a bit
repetitive so there might be a better way to do it.</p>
<p>What <code>next</code> is doing is basic, but at the heart of the instruction decoding:
- Get the current byte
- Match it with an opcode
- If the opcode needs additional data from the instruction vector, extract them
- Move pc to the next instruction
- Return Opcode if found</p>
<p>For the <code>PUSH</code> instructions, pc is incremented multiple times.</p>
<h3>Peeking inside the code</h3>
<p><code>next</code> will give us the next instruction to execute. For now, I am just going to print it to
the console without extra logic. This will be useful in the future to debug our code. </p>
<p>The easiest way is to make our enum derive from <code>Debug</code>. Then we'll be able to print the enum
name with <code>println!</code>.</p>
<pre class="code literal-block"><span></span><span class="cp">#[derive(Debug)]</span><span class="w"></span>
<span class="k">enum</span> <span class="nc">Opcode</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">run</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="p">...</span><span class="w"></span>

<span class="w">    </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">vm</span><span class="p">.</span><span class="n">next</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">),</span><span class="w"></span>
<span class="w">            </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre>


<p>Just by doing so, I have the following output.</p>
<blockquote>
<p>ADD
PUSH1(0)
STOP
MUL
STOP
thread 'main' panicked at 'index out of bounds: the len is 143 but the index is 143', libcore/slice/mod.rs:2046:10</p>
</blockquote>
<p>This is good, but we can do much better. First, just display the enumeration name and content does not give enough information. I'd like a description of the opcode and the address of the opcode in the binary. Second, this panic should not be there, as our program executed as expected.</p>
<p>To avoid the panic, I'll add a secret Opcode (sshh) that signifies our program ends. We could break on None in the loop but I still want to intepret the whole code even if there are codes I
haven't implemented yet. So let's add <code>EOF</code> to our Opcode enumeration. In reality, 0x00 will
take care of that.</p>
<p>Before the match in <code>next</code>:</p>
<pre class="code literal-block"><span></span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">pc</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">code</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">Opcode</span>::<span class="n">EOF</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
</pre>


<p>And in the match of the main loop:</p>
<pre class="code literal-block"><span></span><span class="w">    </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">vm</span><span class="p">.</span><span class="n">next</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="n">Opcode</span>::<span class="n">EOF</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">break</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">),</span><span class="w"></span>
<span class="w">            </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
</pre>


<p>Happy days!</p>
<p>At last, I want to print more information. so let's add the instruction number and the description for each enum.</p>
<pre class="code literal-block"><span></span><span class="cp">#[derive(Debug)]</span><span class="w"></span>
<span class="k">enum</span> <span class="nc">Opcode</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">STOP</span><span class="p">(</span><span class="kt">usize</span><span class="p">),</span><span class="w"> </span><span class="c1">// 0x00</span>
<span class="w">    </span><span class="n">ADD</span><span class="p">(</span><span class="kt">usize</span><span class="p">),</span><span class="w"> </span><span class="c1">// 0x01</span>
<span class="w">    </span><span class="n">MUL</span><span class="p">(</span><span class="kt">usize</span><span class="p">),</span><span class="w"> </span><span class="c1">// 0x02</span>

<span class="w">    </span><span class="n">PUSH1</span><span class="p">(</span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">),</span><span class="w"> </span><span class="c1">// 0x60</span>
<span class="w">    </span><span class="n">PUSH2</span><span class="p">(</span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">),</span><span class="w"> </span><span class="c1">// 0x61</span>
<span class="w">    </span><span class="n">PUSH32</span><span class="p">(</span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">),</span><span class="w"> </span><span class="c1">// 0x7f </span>

<span class="w">    </span><span class="n">EOF</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre>


<p>And next will become:</p>
<pre class="code literal-block"><span></span><span class="w">    </span><span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Opcode</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">pc</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">code</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">Opcode</span>::<span class="n">EOF</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">pc</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">code</span><span class="p">[</span><span class="n">addr</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">             </span><span class="mh">0x00</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="bp">self</span><span class="p">.</span><span class="n">pc</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="nb">Some</span><span class="p">(</span><span class="n">Opcode</span>::<span class="n">STOP</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span><span class="w"></span>
<span class="w">            </span><span class="p">},</span><span class="w"></span>
<span class="w">            </span><span class="mh">0x01</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="bp">self</span><span class="p">.</span><span class="n">pc</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="nb">Some</span><span class="p">(</span><span class="n">Opcode</span>::<span class="n">ADD</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span><span class="w"></span>
<span class="w">            </span><span class="p">},</span><span class="w"></span>
<span class="w">            </span><span class="mh">0x02</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="bp">self</span><span class="p">.</span><span class="n">pc</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="nb">Some</span><span class="p">(</span><span class="n">Opcode</span>::<span class="n">MUL</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span><span class="w"></span>
<span class="w">            </span><span class="p">},</span><span class="w"></span>
<span class="w">            </span><span class="mh">0x60</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">code</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">pc</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="w">                </span><span class="bp">self</span><span class="p">.</span><span class="n">pc</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="nb">Some</span><span class="p">(</span><span class="n">Opcode</span>::<span class="n">PUSH1</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">))</span><span class="w"></span>
<span class="w">            </span><span class="p">},</span><span class="w"></span>
<span class="w">            </span><span class="mh">0x61</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">value0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">code</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">pc</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">value1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">code</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">pc</span><span class="o">+</span><span class="mi">2</span><span class="p">];</span><span class="w"></span>
<span class="w">                </span><span class="bp">self</span><span class="p">.</span><span class="n">pc</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="nb">Some</span><span class="p">(</span><span class="n">Opcode</span>::<span class="n">PUSH2</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">value0</span><span class="p">,</span><span class="w"> </span><span class="n">value1</span><span class="p">))</span><span class="w"></span>
<span class="w">            </span><span class="p">},</span><span class="w"></span>
<span class="w">            </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">pc</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">  </span><span class="nb">None</span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
</pre>


<p>Now we can create a function that will describe the opcode.</p>
<pre class="code literal-block"><span></span><span class="k">impl</span><span class="w"> </span><span class="n">Opcode</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">describe</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="bp">self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">Opcode</span>::<span class="n">STOP</span><span class="p">(</span><span class="n">line</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">"0x{:x}</span><span class="se">\t</span><span class="s">STOP</span><span class="se">\t</span><span class="s">Halts execution"</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="n">Opcode</span>::<span class="n">ADD</span><span class="p">(</span><span class="n">line</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">"0x{:x}</span><span class="se">\t</span><span class="s">ADD</span><span class="se">\t</span><span class="s">Addition operation"</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="n">Opcode</span>::<span class="n">MUL</span><span class="p">(</span><span class="n">line</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">"0x{:x}</span><span class="se">\t</span><span class="s">MUL</span><span class="se">\t</span><span class="s">Multiplication operation"</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="n">Opcode</span>::<span class="n">PUSH1</span><span class="p">(</span><span class="n">line</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">"0x{:x}</span><span class="se">\t</span><span class="s">PUSH1</span><span class="se">\t</span><span class="s">Place 1-byte item on the stack 0x{:x}"</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="n">Opcode</span>::<span class="n">PUSH2</span><span class="p">(</span><span class="n">line</span><span class="p">,</span><span class="w"> </span><span class="n">x0</span><span class="p">,</span><span class="w"> </span><span class="n">x1</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">"0x{:x}</span><span class="se">\t</span><span class="s">PUSH2</span><span class="se">\t</span><span class="s">Place 2-bytes item on the stack 0x{:x} 0x{:x}"</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="p">,</span><span class="w"> </span><span class="n">x0</span><span class="p">,</span><span class="w"> </span><span class="n">x1</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">"Unknown opcode"</span><span class="p">)</span><span class="w"></span>

<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>


<span class="c1">// update run function</span>
<span class="k">fn</span> <span class="nf">run</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">Error</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">filename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"Addition.bin-runtime"</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">"In file {}"</span><span class="p">,</span><span class="w"> </span><span class="n">filename</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">vm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Vm</span>::<span class="n">new_from_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">filename</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">vm</span><span class="p">.</span><span class="n">next</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="n">Opcode</span>::<span class="n">EOF</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">break</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">describe</span><span class="p">(),</span><span class="w"></span>
<span class="w">            </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre>


<h3>A final word</h3>
<p>I showed in this article how to create a tool to display the instructions from an ethereum smart contract binary. It is not complete: the <code>describe</code> and <code>next</code> method have to be populated with all the opcodes in order to be complete.</p>
<p>In the next article I will introduce the memory layout of the EVM. We'll talk about concepts such as stack, memory and persistent storage.</p>
</div>
    </div>
    <aside class="postpromonav"><nav><ul class="pager hidden-print">
<li class="previous">
                <a href="../slug/" rel="prev" title="Bezier curve in Unity: Bounding boxes">Previous post</a>
            </li>
        </ul></nav></aside><section class="comments hidden-print"><h2>Comments</h2>
        
        
        <div id="disqus_thread"></div>
        <script>
        var disqus_shortname ="https-snoozetime-github-io",
            disqus_url="http://snoozetime.github.io/posts/ethereum-virtual-machine-in-rust-part-1/",
        disqus_title="Ethereum Virtual Machine in Rust - Part 1",
        disqus_identifier="cache/posts/ethereum-virtual-machine-in-rust-part-1.html",
        disqus_config = function () {
            this.language = "en";
        };
        (function() {
            var dsq = document.createElement('script'); dsq.async = true;
            dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
</noscript>
    <a href="https://disqus.com" class="dsq-brlink" rel="nofollow">Comments powered by <span class="logo-disqus">Disqus</span></a>


        </section></article><script>var disqus_shortname="https-snoozetime-github-io";(function(){var a=document.createElement("script");a.async=true;a.src="https://"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script><!--End of body content--><footer id="footer">
            Contents © 2018         <a href="mailto:benoit.eudier@gmail.com">Snoozetime</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         
            
        </footer>
</div>
</div>


        <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script>
</body>
</html>
