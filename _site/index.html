<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      SnoozeTime &middot; Programming & various topics
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/blackdoc.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=EB+Garamond">
  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

</head>


  <body>

    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>
        <a href="/">
          SnoozeTime
        </a>
      </h1>
      <p class="lead">Articles about my interest in programming (Videos games, cryptocurrency)</p>
    </div>

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item active" href="/">Home</a>

      

      
      
        
          
        
      
        
      
        
          
        
      
        
          
            <a class="sidebar-nav-item" href="/styles.html">Theme Styles</a>
          
        
      
        
      
        
          
        
      

      <a class="sidebar-nav-item" href="/archive/master.zip">Download</a>
      <hr>
      <a class="sidebar-nav-item" href="">GitHub project</a>
      <span class="sidebar-nav-item">Currently v2.0.1</span>
    </nav>

    <p>&copy; 2018. All rights reserved.</p>
  </div>
</div>


    <div class="content container">
      <div class="posts">
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2018/11/09/ethereum-vm-1.html">
        Ethereum Virtual Machine in Rust - Part 1
      </a>
    </h1>

    <span class="post-date">09 Nov 2018</span>

    <h1 id="exploring-ethereum-virtual-machine">Exploring Ethereum Virtual Machine</h1>

<p>Welcome to the great series - if everything goes well - about the Ethereum Virtual machine.
Lately I have been growing fond of emulation and cryptocurrency so I decided to take a look
at the inside of Ethereum: the virtual machine that is executing smart contracts.</p>

<p>And while implementing a fake EVM (Ethereum Virtual Machine) can be a challenge, why not do
it in a language I have absolutely no experience in. After these few lines, I realize the
probabilities I finish this serie of blog post is meager at best.</p>

<p>Anyway let’s get started. In this first part I’ll talk about compiling a solidity contract
to binary file, and creating a small program to read each instruction.</p>

<h2 id="our-amazing-smart-contract">Our Amazing smart contract</h2>

<p>Take a look at this beauty.</p>

<pre><code class="language-solidity">pragma solidity ^0.4.0;

contract Addition{

	int public x;
    
    function add(int a, int b) public {
    	x = a + b;
   	}
}
</code></pre>

<p>It’s not doing much. Anybody can call <code class="highlighter-rouge">add</code> which will just store the addition of its
argument in the ledger. Then anybody can read the value.</p>

<p>Then, run <code class="highlighter-rouge">solc --bin-runtime --optimize -o . contract.sol</code> to output the compiled contract  binary code to the current directory.</p>

<p>On my computer, I get:</p>
<blockquote>
  <p>608060405260043610603e5763ffffffff7c0100000000000000000000000000000000000000000000000000000000600035041663a5f3c23b81146043575b600080fd5b348015604e57600080fd5b50605b600435602435605d565b005b016000555600a165627a7a723058204ff1427599e28990ab2413948c03501a48ab89d18888ac7d0205c12f443424070029</p>
</blockquote>

<p>By the way, this is an hexadecimal string. This is going to be important when we read it from Rust (https://solidity.readthedocs.io/en/v0.4.21/using-the-compiler.html)</p>

<h2 id="reading-the-binary-file">Reading the binary file</h2>

<p>Rust makes it quite easy to read data from a file.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fs</span><span class="p">::</span><span class="n">File</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="nn">prelude</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">error</span><span class="p">::</span><span class="n">Error</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">run</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">Error</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">filename</span> <span class="o">=</span> <span class="s">"myfilename"</span><span class="p">;</span>
    
    <span class="k">let</span> <span class="k">mut</span> <span class="n">f</span> <span class="o">=</span> <span class="nn">File</span><span class="p">::</span><span class="nf">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">buffer</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="n">f</span><span class="nf">.read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">buffer</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">run</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
<span class="p">}</span>

</code></pre></div></div>

<p>This is going to print the content of our file. Right now, the whole code is loaded in the
string. There might be better way to do it but ultimately the code is always loaded in the RAM
of the EVM. Also, the smart contracts tend to be small so it should be no problem to do it like
that.</p>

<h2 id="opcode-and-virtual-machine-execution">Opcode and Virtual machine execution</h2>

<p>A virtual machine, such as the Java Virtual Machine, will take a set of instructions and execute
them. in Java the set of instruction is in the Java bytecode (https://en.wikipedia.org/wiki/Java_bytecode). In Ethereum, the set of instruction is the content of the binary file we just read. The instruction set is described in the Ethereum Yellow paper, in the appendix. https://ethereum.github.io/yellowpaper/paper.pdf</p>

<p>For example, the value 0x30 corresponds to the ADDRESS instruction (or opcode) and tells the
ethereum VM to get the address of currently executed account. Let’s not worry about all the technical terms for now. Just keep in mind that our binary file is a set of instructions, and
each instructions are 8 bits, or 1 byte, long.</p>

<p>Our file content is an hexadecimal string, so we can represent the first bytes as:
<em>0x60</em> <em>0x80</em> <em>0x60</em> <em>0x40</em> <em>0x52</em>
If you look at the specifications, you can convert to a more readable format:</p>
<ul>
  <li>PUSH one byte to stack: 0x80</li>
  <li>PUSH one byte to stack: 0x40</li>
  <li>STORE one word to memory</li>
</ul>

<p>Next step in our program is to convert our string to a list of bytes (<code class="highlighter-rouge">u8</code> in Rust).</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">num</span><span class="p">::</span><span class="n">ParseIntError</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">decode</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ParseIntError</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="p">(</span><span class="n">s</span><span class="nf">.len</span><span class="p">()</span><span class="err">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="nf">.step_by</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">i</span><span class="p">|</span> <span class="nn">u8</span><span class="p">::</span><span class="nf">from_str_radix</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">..</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">],</span> <span class="mi">16</span><span class="p">))</span>
        <span class="nf">.collect</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>
<p>It will construct a vector of bytes. Function composition here makes the code very expressive:</p>
<ul>
  <li>We get an iterator from 0 to the length of our string (excluded)</li>
  <li>We get another iterator that will yield the first iterator elements with a step of 2. (Yield 0, 2, 4, 6… and so on)</li>
  <li>Then, for each index, we apply <code class="highlighter-rouge">u8::from_str_radix</code> to the slice [i..i+2] of our input string. This is going to convert the string to a <code class="highlighter-rouge">u8</code> integer, base 16. This can panic in case the string does not represent a valid integer base 16 (‘P0’ would panic)</li>
  <li>We consume the iterators with collect.</li>
</ul>

<p>Iterators are lazy in Rust, so we need to call collect at the end to consume them. See here for more details: https://doc.rust-lang.org/book/second-edition/ch13-02-iterators.html</p>

<p>The Result trait implements FromIter, so instead of returning <code class="highlighter-rouge">Vec&lt;Result&lt;u8, ParseIntError&gt;&gt;</code>, we can return <code class="highlighter-rouge">Result&lt;Vec&lt;u8&gt;, ParseIntError&gt;</code>. See also here https://doc.rust-lang.org/std/result/enum.Result.html#method.from_iter</p>

<p>Now we can print our bytes from the files.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">fn</span> <span class="nf">run</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">Error</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">filename</span> <span class="o">=</span> <span class="s">"myfilename"</span><span class="p">;</span>
    
    <span class="k">let</span> <span class="k">mut</span> <span class="n">f</span> <span class="o">=</span> <span class="nn">File</span><span class="p">::</span><span class="nf">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">buffer</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="n">f</span><span class="nf">.read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">buffer</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    
    <span class="k">let</span> <span class="n">bytes</span> <span class="o">=</span> <span class="nf">decode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    
    <span class="k">for</span> <span class="n">b</span> <span class="n">in</span> <span class="o">&amp;</span><span class="n">bytes</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"0x{:x}"</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> 
    <span class="p">}</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="our-simple-evm">Our simple EVM</h2>

<p>Now that we can read the bytes of our compiled smart contract, let’s start the implementation
of the VM. I am just going to show how to print debug information about the instructions in this
part. We are going to iterate over the list of instructions and print what they mean. No stack
or memory involved here :)</p>

<p>The most basic VM will hold the code in memory, and will iterate through it. We could use range-based loop to do the iteration, but you will see later that it won’t work nicely with our use case.
For example, not all instructions are only one byte long. Some, such as PUSH3, are 4 bytes long (one byte for the instruction value, and 3 bytes for the value to push to the stack).</p>

<p>For that reason, I am going to keep an index of the current instruction in the code vector. This index is often called pc, for program counter.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">struct</span> <span class="n">Vm</span> <span class="p">{</span>
    <span class="n">code</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">,</span> <span class="c">// smart contract code</span>
    <span class="n">pc</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="c">// current instruction</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Vm</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">new_from_file</span><span class="p">(</span><span class="n">filename</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">Vm</span><span class="p">,</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">Error</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">f</span> <span class="o">=</span> <span class="nn">File</span><span class="p">::</span><span class="nf">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">buffer</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="n">f</span><span class="nf">.read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">buffer</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

        <span class="k">let</span> <span class="n">code</span> <span class="o">=</span> <span class="nf">decode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="n">Vm</span> <span class="p">{</span> <span class="n">code</span><span class="p">:</span> <span class="n">code</span><span class="p">,</span> <span class="n">pc</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p><code class="highlighter-rouge">new_from_file</code> will initialize us a new VM. Then, we need a way to model the instruction. I found enumeration in Rust well suited for this as they are very flexible. I also really like
the pattern matching with enumerations.</p>

<p>Let’s get started. There are more than an hundred instructions in the EVM instruction set so
I’ll just show a few of them.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">enum</span> <span class="n">Opcode</span> <span class="p">{</span>

    <span class="n">STOP</span><span class="p">,</span> <span class="c">// 0x00</span>
    <span class="n">ADD</span><span class="p">,</span> <span class="c">// 0x01</span>
    <span class="n">MUL</span><span class="p">,</span> <span class="c">// 0x02</span>
    
    <span class="nf">PUSH1</span><span class="p">(</span><span class="nb">u8</span><span class="p">),</span> <span class="c">// 0x60</span>
    <span class="nf">PUSH2</span><span class="p">(</span><span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">),</span> <span class="c">// 0x61</span>
    
    <span class="nf">PUSH32</span><span class="p">(</span><span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">),</span> <span class="c">// 0x7f </span>
<span class="p">}</span>

</code></pre></div></div>
<p><code class="highlighter-rouge">PUSH1(u8)</code> means that the instruction is made of 2 bytes. First byte is the instruction value, 
second byte is the value to push to the stack. We are going to store this value in the enumeration.</p>

<p>Now that we have our Opcode enumeration, we need to yield opcodes from the list of bytes. This is called decoding. The <code class="highlighter-rouge">next</code> function will return the Opcode at the current pc, and then advance pc to the next instruction.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">Vm</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Opcode</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">match</span> <span class="k">self</span><span class="py">.code</span><span class="p">[</span><span class="k">self</span><span class="py">.pc</span><span class="p">]</span> <span class="p">{</span>
            <span class="mi">0x00</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.pc</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="nf">Some</span><span class="p">(</span><span class="nn">Opcode</span><span class="p">::</span><span class="n">STOP</span><span class="p">)</span>
            <span class="p">},</span>
            <span class="mi">0x01</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.pc</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="nf">Some</span><span class="p">(</span><span class="nn">Opcode</span><span class="p">::</span><span class="n">ADD</span><span class="p">)</span>
            <span class="p">},</span>
            <span class="mi">0x02</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.pc</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="nf">Some</span><span class="p">(</span><span class="nn">Opcode</span><span class="p">::</span><span class="n">MUL</span><span class="p">)</span>
            <span class="p">},</span>
            <span class="mi">0x60</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">value</span> <span class="o">=</span> <span class="k">self</span><span class="py">.code</span><span class="p">[</span><span class="k">self</span><span class="py">.pc</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
                <span class="k">self</span><span class="py">.pc</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
                <span class="nf">Some</span><span class="p">(</span><span class="nn">Opcode</span><span class="p">::</span><span class="nf">PUSH1</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
            <span class="p">},</span>
            <span class="n">Ox61</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">value0</span> <span class="o">=</span> <span class="k">self</span><span class="py">.code</span><span class="p">[</span><span class="k">self</span><span class="py">.pc</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
                <span class="k">let</span> <span class="n">value1</span> <span class="o">=</span> <span class="k">self</span><span class="py">.code</span><span class="p">[</span><span class="k">self</span><span class="py">.pc</span><span class="o">+</span><span class="mi">2</span><span class="p">];</span>
                <span class="k">self</span><span class="py">.pc</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">;</span>
                <span class="nf">Some</span><span class="p">(</span><span class="nn">Opcode</span><span class="p">::</span><span class="nf">PUSH2</span><span class="p">(</span><span class="n">value0</span><span class="p">,</span> <span class="n">value1</span><span class="p">))</span>
            <span class="p">}</span>
            <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="k">self</span><span class="py">.pc</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span> <span class="nb">None</span><span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Right now, I ignore the error cases (for example, buffer overflow). Rust will panic if I try to
access values with indexes that are larger that the size of the vector. Also, the code is a bit
repetitive so there might be a better way to do it.</p>

<p>What <code class="highlighter-rouge">next</code> is doing is basic, but at the heart of the instruction decoding:</p>
<ul>
  <li>Get the current byte</li>
  <li>Match it with an opcode</li>
  <li>If the opcode needs additional data from the instruction vector, extract them</li>
  <li>Move pc to the next instruction</li>
  <li>Return Opcode if found</li>
</ul>

<p>For the <code class="highlighter-rouge">PUSH</code> instructions, pc is incremented multiple times.</p>

<h2 id="peeking-inside-the-code">Peeking inside the code</h2>

<p><code class="highlighter-rouge">next</code> will give us the next instruction to execute. For now, I am just going to print it to
the console without extra logic. This will be useful in the future to debug our code.</p>

<p>The easiest way is to make our enum derive from <code class="highlighter-rouge">Debug</code>. Then we’ll be able to print the enum
name with <code class="highlighter-rouge">println!</code>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="nd">#[derive(Debug)]</span>
<span class="k">enum</span> <span class="n">Opcode</span> <span class="p">{</span>
<span class="o">...</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">run</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="p">{</span>

    <span class="o">...</span>
    
    <span class="k">loop</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">vm</span><span class="nf">.next</span><span class="p">()</span> <span class="p">{</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span>
            <span class="nb">None</span> <span class="k">=&gt;</span> <span class="p">{}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Just by doing so, I have the following output.</p>
<blockquote>
  <p>ADD
PUSH1(0)
STOP
MUL
STOP
thread ‘main’ panicked at ‘index out of bounds: the len is 143 but the index is 143’, libcore/slice/mod.rs:2046:10</p>
</blockquote>

<p>This is good, but we can do much better. First, just display the enumeration name and content does not give enough information. I’d like a description of the opcode and the address of the opcode in the binary. Second, this panic should not be there, as our program executed as expected.</p>

<p>To avoid the panic, I’ll add a secret Opcode (sshh) that signifies our program ends. We could break on None in the loop but I still want to intepret the whole code even if there are codes I
haven’t implemented yet. So let’s add <code class="highlighter-rouge">EOF</code> to our Opcode enumeration. In reality, 0x00 will
take care of that.</p>

<p>Before the match in <code class="highlighter-rouge">next</code>:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">if</span> <span class="k">self</span><span class="py">.pc</span> <span class="o">&gt;=</span> <span class="k">self</span><span class="py">.code</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">Opcode</span><span class="p">::</span><span class="n">EOF</span><span class="p">);</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>And in the match of the main loop:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">loop</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">vm</span><span class="nf">.next</span><span class="p">()</span> <span class="p">{</span>
            <span class="nf">Some</span><span class="p">(</span><span class="nn">Opcode</span><span class="p">::</span><span class="n">EOF</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">break</span><span class="p">,</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span>
            <span class="nb">None</span> <span class="k">=&gt;</span> <span class="p">{}</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>
<p>Happy days!</p>

<p>At last, I want to print more information. so let’s add the instruction number and the description for each enum.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="nd">#[derive(Debug)]</span>
<span class="k">enum</span> <span class="n">Opcode</span> <span class="p">{</span>
    <span class="nf">STOP</span><span class="p">(</span><span class="nb">usize</span><span class="p">),</span> <span class="c">// 0x00</span>
    <span class="nf">ADD</span><span class="p">(</span><span class="nb">usize</span><span class="p">),</span> <span class="c">// 0x01</span>
    <span class="nf">MUL</span><span class="p">(</span><span class="nb">usize</span><span class="p">),</span> <span class="c">// 0x02</span>

    <span class="nf">PUSH1</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">u8</span><span class="p">),</span> <span class="c">// 0x60</span>
    <span class="nf">PUSH2</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">),</span> <span class="c">// 0x61</span>
    <span class="nf">PUSH32</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">),</span> <span class="c">// 0x7f </span>

    <span class="n">EOF</span><span class="p">,</span>
<span class="p">}</span>

</code></pre></div></div>

<p>And next will become:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Opcode</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.pc</span> <span class="o">&gt;=</span> <span class="k">self</span><span class="py">.code</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">Opcode</span><span class="p">::</span><span class="n">EOF</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">addr</span> <span class="o">=</span> <span class="k">self</span><span class="py">.pc</span><span class="p">;</span>
        <span class="k">match</span> <span class="k">self</span><span class="py">.code</span><span class="p">[</span><span class="n">addr</span><span class="p">]</span> <span class="p">{</span>
             <span class="mi">0x00</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.pc</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="nf">Some</span><span class="p">(</span><span class="nn">Opcode</span><span class="p">::</span><span class="nf">STOP</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span>
            <span class="p">},</span>
            <span class="mi">0x01</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.pc</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="nf">Some</span><span class="p">(</span><span class="nn">Opcode</span><span class="p">::</span><span class="nf">ADD</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span>
            <span class="p">},</span>
            <span class="mi">0x02</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.pc</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="nf">Some</span><span class="p">(</span><span class="nn">Opcode</span><span class="p">::</span><span class="nf">MUL</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span>
            <span class="p">},</span>
            <span class="mi">0x60</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">value</span> <span class="o">=</span> <span class="k">self</span><span class="py">.code</span><span class="p">[</span><span class="k">self</span><span class="py">.pc</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
                <span class="k">self</span><span class="py">.pc</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
                <span class="nf">Some</span><span class="p">(</span><span class="nn">Opcode</span><span class="p">::</span><span class="nf">PUSH1</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
            <span class="p">},</span>
            <span class="mi">0x61</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">value0</span> <span class="o">=</span> <span class="k">self</span><span class="py">.code</span><span class="p">[</span><span class="k">self</span><span class="py">.pc</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
                <span class="k">let</span> <span class="n">value1</span> <span class="o">=</span> <span class="k">self</span><span class="py">.code</span><span class="p">[</span><span class="k">self</span><span class="py">.pc</span><span class="o">+</span><span class="mi">2</span><span class="p">];</span>
                <span class="k">self</span><span class="py">.pc</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">;</span>
                <span class="nf">Some</span><span class="p">(</span><span class="nn">Opcode</span><span class="p">::</span><span class="nf">PUSH2</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">value0</span><span class="p">,</span> <span class="n">value1</span><span class="p">))</span>
            <span class="p">},</span>
            <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="k">self</span><span class="py">.pc</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>  <span class="nb">None</span><span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>Now we can create a function that will describe the opcode.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">impl</span> <span class="n">Opcode</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">describe</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
        <span class="nn">Opcode</span><span class="p">::</span><span class="nf">STOP</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"0x{:x}</span><span class="se">\t</span><span class="s">STOP</span><span class="se">\t</span><span class="s">Halts execution"</span><span class="p">,</span> <span class="n">line</span><span class="p">),</span>
        <span class="nn">Opcode</span><span class="p">::</span><span class="nf">ADD</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"0x{:x}</span><span class="se">\t</span><span class="s">ADD</span><span class="se">\t</span><span class="s">Addition operation"</span><span class="p">,</span> <span class="n">line</span><span class="p">),</span>
        <span class="nn">Opcode</span><span class="p">::</span><span class="nf">MUL</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"0x{:x}</span><span class="se">\t</span><span class="s">MUL</span><span class="se">\t</span><span class="s">Multiplication operation"</span><span class="p">,</span> <span class="n">line</span><span class="p">),</span>
        <span class="nn">Opcode</span><span class="p">::</span><span class="nf">PUSH1</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"0x{:x}</span><span class="se">\t</span><span class="s">PUSH1</span><span class="se">\t</span><span class="s">Place 1-byte item on the stack 0x{:x}"</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span>
        <span class="nn">Opcode</span><span class="p">::</span><span class="nf">PUSH2</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"0x{:x}</span><span class="se">\t</span><span class="s">PUSH2</span><span class="se">\t</span><span class="s">Place 2-bytes item on the stack 0x{:x} 0x{:x}"</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">),</span>
        <span class="n">_</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"Unknown opcode"</span><span class="p">)</span>
 
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="c">// update run function</span>
<span class="k">fn</span> <span class="nf">run</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">Error</span><span class="o">&gt;&gt;</span> <span class="p">{</span>

    <span class="k">let</span> <span class="n">filename</span> <span class="o">=</span> <span class="s">"Addition.bin-runtime"</span><span class="p">;</span>
    
    <span class="nd">println!</span><span class="p">(</span><span class="s">"In file {}"</span><span class="p">,</span> <span class="n">filename</span><span class="p">);</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">vm</span> <span class="o">=</span> <span class="nn">Vm</span><span class="p">::</span><span class="nf">new_from_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">filename</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">vm</span><span class="nf">.next</span><span class="p">()</span> <span class="p">{</span>
            <span class="nf">Some</span><span class="p">(</span><span class="nn">Opcode</span><span class="p">::</span><span class="n">EOF</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">break</span><span class="p">,</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">x</span><span class="nf">.describe</span><span class="p">(),</span>
            <span class="nb">None</span> <span class="k">=&gt;</span> <span class="p">{}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="a-final-word">A final word</h2>

<p>I showed in this article how to create a tool to display the instructions from an ethereum smart contract binary. It is not complete: the <code class="highlighter-rouge">describe</code> and <code class="highlighter-rouge">next</code> method have to be populated with all the opcodes in order to be complete.</p>

<p>In the next article I will introduce the memory layout of the EVM. We’ll talk about concepts such as stack, memory and persistent storage.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2018/05/22/bezier-curve-bounding-box.html">
        Bezier curve in Unity: Bounding Boxes
      </a>
    </h1>

    <span class="post-date">22 May 2018</span>

    <p><a href="http://localhost:4000/assets/micromachine.jpg"></a></p>

<p>Instead of the common FPS/RPG/Platformer, for some reason I decide to
create a clone of the old micromachine, in particular the elimination
mode when players are eliminated when they are too far away from the
first player.</p>

<p>As the game was creating itself in my head, I stumbled against a
mathematical obstacle in the first week of prototyping. How to determine
which player is the first? How to determinate what path the AI should
follow.</p>

<p>It turns out that part of the answer is to represent tracks as a curve,
and Bezier curves are used in a bunch of applications from photoshop to
font creation. To find out what player is first, I would just have to
calculate the position of all pilots on the tracks.</p>

<h1 id="some-reading-before-getting-started">Some reading before getting started</h1>

<p>This article will be introducing a bit a linear algebra. In particular,
we will apply translation and rotation to our vectors. Also, we need to
find the roots of a quadratic equation. The maths are not too
complicated but feel free to read the following links beforehand:</p>

<ul>
  <li><a href="https://en.wikipedia.org/wiki/Quadratic_equation">Wikipedia article on finding the roots of a quadratic
formula</a></li>
  <li><a href="http://planning.cs.uiuc.edu/node97.html">Description of translation, rotation and their
combinaison</a></li>
</ul>

<p>This article builds on an existing article which can be found here:
<a href="https://catlikecoding.com/unity/tutorials/curves-and-splines/">https://catlikecoding.com/unity/tutorials/curves-and-splines/</a> It shows
how to implement a Bezier curve in Unity, showing at the same time how
editor scripts work.</p>

<p>The last resource is an ebook called “A primer on Bezier”. It can be
found <a href="https://pomax.github.io/bezierinfo/">here.</a> This ebook contains
all you need to know about Bezier curves, theory and pseudocode
included.</p>

<p><img src="http://localhost:4000/assets/bezier_initial.png" alt="Initial bezier situation" /></p>

<h1 id="bounding-box">Bounding box</h1>

<p>Bounding box are useful. In my use case, I want to find the closest
point to the spline so bounding boxes will help determine what bezier
curve I should select to do the calculation!</p>

<p>The way to find the bounding box is to get the minimum/maximum along the
x and y axis and create the boxes from (<script type="math/tex">x_{min}</script>, <script type="math/tex">y_{min}</script>), (<script type="math/tex">x_{min}</script>,
<script type="math/tex">y_{max}</script>), (<script type="math/tex">x_{max}</script>, <script type="math/tex">y_{min}</script>), (<script type="math/tex">x_{max}</script>, <script type="math/tex">y_{max}</script>).</p>

<p>However, this has the tendency to create large bounding boxes so we can
get tighter boxes by aligning them along our curve. (<a href="https://pomax.github.io/bezierinfo/#boundingbox">Part 17 - Bounding
box</a>)</p>

<h2 id="beforehand-define-the-curve">Beforehand, define the curve</h2>

<p>Curve is such as</p>

<script type="math/tex; mode=display">B(t) = (1-t)^3P_0 + 3(1-t)^2tP_1 + 3(1-t)t^2P_2 + t^3P_3</script>

<p>where <script type="math/tex">P_0, P_1, P_2, P_3</script> are the control points of the curve, in
global coordinates.</p>

<h2 id="align-the-curve-on-an-axis">Align the curve on an axis.</h2>

<p>To align the curve, we first need to apply a translation T to the first
point of the curve in order to place it on the origin (0, 0). We have
<script type="math/tex">T = -P_0</script>.</p>

<pre><code class="language-{.csharp}">// Translation such as p0 is at (0,0)
Vector2 [] translatedVector = new Vector2[] {
    p0 - p0,
    p1 - p0,
    p2 - p0,
    p3 - p0
};
</code></pre>

<p>Then, we need to apply the rotation so that $P_3$ is on the x-axis.
Given x and y the coordinates of $P_3$, x’ and y’ the coordinates after
rotation $\theta$, we have the equations:</p>

<p>\begin{equation}
x’ = xcos(theta) - ysin(theta)</p>

<p>y’ = ycos(theta) + x sin(theta)
\end{equation}</p>

<p><a href="https://www.siggraph.org/education/materials/HyperGraph/modeling/mod_tran/2drota.htm">Don’t take my word for granted
:)</a></p>

<pre><code class="language-{.csharp}">
private static Vector2 Rotate(Vector2 p, float theta) {
    // x' = x cos f - y sin f
    // y' = y cos f + x sin f
    float xp = p.x * Mathf.Cos(theta) - p.y * Mathf.Sin(theta);
    float yp = p.y * Mathf.Cos(theta) + p.x * Mathf.Sin(theta);

    return new Vector2(xp, yp);
}

</code></pre>

<p>We find theta such as <script type="math/tex">y' = 0</script>.</p>

<script type="math/tex; mode=display">\theta = atan(-y/x)</script>

<pre><code class="language-{.csharp}">// Find rotation such as translatedVector[3] is on the axis
Vector2 pp3 = translatedVector[3];
float theta = Mathf.Atan(-pp3.y/pp3.x);
</code></pre>

<p>Just for fun, let’s draw the Bezier curve after rotation.</p>

<pre><code class="language-{.csharp}">
public static Vector2[] GetAlignedCurve(Vector2 p0, Vector2 p1, Vector2 p2, Vector2 p3) {

    // Translation such as p0 is at (0,0)
    Vector2 [] translatedVector = new Vector2[] {
        p0 - p0,
        p1 - p0,
        p2 - p0,
        p3 - p0
    };

    // Find rotation such as translatedVector[3] is on the axis
    Vector2 pp3 = translatedVector[3];
    float theta = Mathf.Atan(-pp3.y/pp3.x);

    // Now calculate new vectors.
    return new Vector2[] {
        Rotate(p0 - p0, theta),
        Rotate(p1 - p0, theta),
        Rotate(p2 - p0, theta),
        Rotate(p3 - p0, theta)
    };
}

</code></pre>

<p>When adding the aligned curve to the editor script, we get the
following.</p>

<p><img src="http://localhost:4000/assets/aligned_bezier.png" alt="" /></p>

<h2 id="find-the-bounding-box-for-the-aligned-curve">Find the bounding box for the aligned curve</h2>

<p>Once we have our aligned curve, we need to find its bounding box. To do
so, we need to calculate the roots of the curve for x and y in order to
get the minimum and maximum on the axis for t between 0 and 1.</p>

<p>To get an idea about why we want the minimum and maximum of a curve,
please refer to my amazing drawing. <img src="http://localhost:4000/assets/bounding_box.png" alt="" /></p>

<p>In this piece of art, the maximum and minimum of y are located on the
curve. For x however, only the minimum x is located on the curve. The
maximum is one of our control point. This is why we absolutely have to
include the first and last control points when we want to find the
minimum and maximum on each axis.</p>

<p>For a quadratic or cubic Bezier curve, it is very easy to find the
minimum and maximum for each axis. The way to do it is to calculate the
derivate of the curve, and find the t values for which this derivative
is 0. These values are called the roots of the curve for the x or y
axis. The Wikipedia article at the top of the blog article explains it
more deeply.</p>

<p>After deriving the Bezier equation and simplifying it a bit, we obtain:</p>

<script type="math/tex; mode=display">3 (-x_{p_0} + 3x_{p_1} - 3x_{p_2} + x_{p_3})t^2 + 6(x_{p_0} - 2x_{p_1} + x_{p_2})t + 3(x_{p_1} - x_{p_0}) = 0</script>

<p>Where $x_{p_i}$ is the x coordinate of the point i. There is the same
equation for y. Now that we have reduce our equation to a simple
quadratic equation, the solution is textbook.</p>

<script type="math/tex; mode=display">a = 3(-x_{p_0} + 3x_{p_1} - 3x_{p_2} + x_{p_3})</script>

<script type="math/tex; mode=display">b = 6(x_{p_0} - 2x_{p_1} + x_{p_2})</script>

<script type="math/tex; mode=display">c = 3(x_{p_1} - x_{p_0})</script>

<script type="math/tex; mode=display">\Delta = b^2 - 4 ac</script>

<p>$\Delta$ (Delta) is the discriminant. We can find imaginary roots (that
cannot be represented in our 2D space) when delta is negative, so here
we are just interested about the real roots, meaning when $\Delta &gt;= 0$.</p>

<p>The two roots (which can be only one is the discriminant is 0) for the
axis x are:</p>

<script type="math/tex; mode=display">t_1 = \frac{-b - \sqrt{\Delta}}{4ac}</script>

<script type="math/tex; mode=display">t_2 = \frac{-b + \sqrt{\Delta}}{4ac}</script>

<p>Notice that when $\Delta$ is 0, $t_1$ and $t_2$ are the same. For our
Bezier curve, we only care about parameter between 0 and 1 so the roots
might not be usable. In C#, there is not much complexity. Just write
down the last equations and filter the values.</p>

<pre><code class="language-{.csharp}">/*
  Find the roots of a cubic bezier curve in order to find minimum and maximum
 */
private static List&lt;float&gt; FindRoots(Vector2 p0, Vector2 p1, Vector2 p2, Vector2 p3) {
    Vector2 a = 3 * (-p0 + 3*p1 - 3*p2 + p3);
    Vector2 b = 6 * (p0 - 2*p1 + p2);
    Vector2 c = 3 * (p1 - p0);

    List&lt;float&gt; roots = new List&lt;float&gt;();

    // along x
    float discriminantX = b.x * b.x - 4 * a.x * c.x;
    if (discriminantX &lt; 0) {
        // No roots
    } else if (discriminantX == 0) {
        // one real root
        float rootx = (-b.x) / (2 * a.x);
        if (rootx &gt;=0 &amp;&amp; rootx &lt;= 1) {
            roots.Add(rootx);
        }
    } else if (discriminantX &gt; 0) {
        // Two real roots
        float rootx1 = (-b.x + Mathf.Sqrt(discriminantX)) / (2 * a.x);
        float rootx2 = (-b.x - Mathf.Sqrt(discriminantX)) / (2 * a.x);
        if (rootx1 &gt;=0 &amp;&amp; rootx1 &lt;= 1) {
            roots.Add(rootx1);
        }
        if (rootx2 &gt;=0 &amp;&amp; rootx2 &lt;= 1) {
            roots.Add(rootx2);
        }
    }

    // along y
    float discriminantY = b.y * b.y - 4 * a.y * c.y;
    if (discriminantY &lt; 0) {
        // No roots
    } else if (discriminantY == 0) {
        // one real root
        float rooty = (-b.y) / (2 * a.y);
        if (rooty &gt;=0 &amp;&amp; rooty &lt;= 1) {
            roots.Add(rooty);
        }
    } else if (discriminantY &gt; 0) {
        // Two real roots
        float rooty1 = (-b.y + Mathf.Sqrt(discriminantY)) / (2 * a.y);
        float rooty2 = (-b.y - Mathf.Sqrt(discriminantY)) / (2 * a.y);
        if (rooty1 &gt;=0 &amp;&amp; rooty1 &lt;= 1) {
            roots.Add(rooty1);
        }
        if (rooty2 &gt;=0 &amp;&amp; rooty2 &lt;= 1) {
            roots.Add(rooty2);
        }
    }

    return roots;
}

</code></pre>

<p>(You can even refactor this to do the calculation once! When reading
back this code I noticed that I was a bit lazy here).</p>

<p>Now, our minimum and maximum along x and y would be one of the point
that has a parameter t, where t is either a root, 0 or 1.</p>

<pre><code class="language-{.csharp}">
List&lt;float&gt; roots = FindRoots(pa0, pa1, pa2, pa3);


// Initialize min and max with the first point
float min_x = Mathf.Min(pa0.x, pa3.x);
float max_x = Mathf.Max(pa0.x, pa3.x);
float min_y = Mathf.Min(pa0.y, pa3.y);
float max_y = Mathf.Max(pa0.y, pa3.y);

for (int i = 0; i &lt; roots.Count; i++) {
    float param = roots[i];
    Vector2 point = GetPoint(pa0, pa1, pa2, pa3, param);

    if (point.x &gt; max_x) {
        max_x = point.x;
    }

    if (point.x &lt; min_x) {
        min_x = point.x;
    }

    if (point.y &gt; max_y) {
        max_y = point.y;
    }

    if (point.y &lt; min_y) {
        min_y = point.y;
    }
}
</code></pre>

<p>We have our $x_min$, $x_max$, $y_min$, $y_max$. This is all we need for
drawing the bounding box.</p>

<p><img src="http://localhost:4000/assets/bounding_box_aligned.png" alt="" /></p>

<h2 id="rotate-the-box-back">Rotate the box back</h2>

<p>Almost there! At this point, we have the bounding box of the aligned
curve. To get the aligned curve, we applied two transformations to our
Bezier curve: first a translation, then a rotation. To get back to the
original curve, you can simply do the inverse! First, rotate the aligned
curve by the opposite of the first rotation ($-\theta$), then translate
it by the opposite of the first translation ($-P_0$).</p>

<p>We can do the same with the bounding box, and it should fit our original
Bezier curve!</p>

<p>With the previous minima and maxima:</p>

<pre><code class="language-{.csharp}">
return new Vector2[] {
    Rotate(new Vector2(min_x, min_y), -theta) + p0,
    Rotate(new Vector2(min_x, max_y), -theta) + p0,
    Rotate(new Vector2(max_x, min_y), -theta) + p0,
    Rotate(new Vector2(max_x, max_y), -theta) + p0,
};

</code></pre>

<p>Which gives us, at last:</p>

<p><img src="http://localhost:4000/assets/bounding_box_final.png" alt="" /></p>

<h1 id="whats-next">What’s next?</h1>

<p>All this to find the bounding boxes of each curve in our Bezier spline!
While it looks like a lot of work, these bounding boxes are really going
to help us find the projection of a point on the spline.</p>

<p>Instead of having to consider all the spline, now we can just reduce the
problem to a list of Bezier curves. Calculating distance to a box is
pretty simple, so we just need to find the closest boxes to our point
and for each curve, finding the closest point. This will be done by an
iterative approach (mathematical approach is out of the question here -
spoiler alert), so keep tuned for the next article.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2018/05/03/random-picture-japan.html">
        Random pictures in Japan
      </a>
    </h1>

    <span class="post-date">03 May 2018</span>

    <p><img src="http://localhost:4000/assets/monkey.jpg" alt="A dude chilling with his monkey" /></p>

<p><img src="http://localhost:4000/assets/konniaku.jpg" alt="An overly dramatic caption" /></p>

<p><img src="http://localhost:4000/assets/cupnoodle.jpg" alt="Preschool fun at the CupNoodle museum in Minato
Mirai" /></p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2018/05/02/code-generation-python.html">
        Code generation with Python
      </a>
    </h1>

    <span class="post-date">02 May 2018</span>

    <p>More often than not, working in a IT project requires a lot of
repetitive tasks. In particular, one area that can be very debilitating
is the creation of test data. We know it is indispensable to the
project, but it does not make that task less boring.</p>

<h1 id="lets-consider-this-example">Let’s consider this example</h1>

<blockquote>
  <p>You are working in a Java project. One of the thing to test is the
validation logic of some input XML files. One object, called the
XmlInputSuperbEnterpriseValidator (notice the Java naming convention),
takes a XML file path as input and return true if the file is valid.</p>
</blockquote>

<p>Input file is just a simple XML file, which could look like this:</p>

<pre><code class="language-{.xml}">&lt;root&gt;
  &lt;value1&gt;1&lt;/value1&gt;
  &lt;value2&gt;a&lt;/value2&gt;
&lt;/root&gt;
</code></pre>

<p>where value1 accepts number between 0 and 9 and value2 accepts letters
(a-z).</p>

<p>To test this, one can create a test class like the following.</p>

<pre><code class="language-{.java}">package com.core.validator;

import static org.junit.Assert.*;

public class XmlInputSuperEnterpriseValidatorTest {

    @Test
    public void 01_normalInput_returnsTrue() {
         assertTrue(XmlInputSuperbEnterpriseValidator.validate("input/01.xml"));
    }
}
</code></pre>

<p>Then, for each test case, create the XML file and add exactly the same
test function.</p>

<h1 id="when-things-go-sideways">When things go sideways</h1>

<p>What if you have 50 different permutations of XML file. You’ll need to
create all of them and create the exact same test methods. And what if
the specification change and you have to add new fields? Here again, a
lot of manual operation will be required to update the test cases.</p>

<p>What could happen here is that the tests will just be thrown away as the
maintenance is taking more effort that most people are willing to give.</p>

<p>As a good little software engineer, one of the question that should pop
out of your mind is: “Isn’t there a better way to do that?”</p>

<h1 id="of-course-there-is-a-better-way">Of course there is a better way</h1>

<p>It’s not rocket science, but using python (or any other language really)
to automate the test creation will save you a bunch of time and also
make everybody in the project happier.</p>

<p>The basic workflow is the following:</p>

<ol>
  <li>Create test data definition: It could be just a simple text file
that describes the tests you want to run.</li>
  <li>Run the script to generate the data and the test class</li>
  <li>Run the tests and enjoy</li>
</ol>

<h2 id="test-definition">Test definition</h2>

<p>The test definition is the input of the generator. We need to specify
what kind of test data we want to generate. In this example, we want to
generate tests that will try all possible permutations for value1 and
value2 of the input file.</p>

<p>The format of the test definition is up to you; here we will just use
plain text.</p>

<pre><code class="language-{.example}">1,2,3,4,5,6,7,8,9
a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z
</code></pre>

<h2 id="generating-the-test-data-and-test-class">Generating the test data and test class</h2>

<h3 id="representing-our-test-data-in-python">Representing our test data in Python</h3>

<p>First things first, let’s create a class that will represent the data
for one test:</p>

<pre><code class="language-{.python}">import os

class TestData:

    def __init__(self, name, path, value1, value2):
        self.value1 = value1
        self.value2 = value2
        self.path = path
        self.name = name

</code></pre>

<p>We have our test data representation, great. Now we need a way to
convert it to text. We could just use Python string interpolation but
there is a much better way.</p>

<h3 id="templating-language-yokoso">Templating language, Yokoso</h3>

<p>A very neat way to generate text file in python is to use a templating
language. Web frameworks, such as Django or Flask, are heavy users of
templating language to generate the HTML pages from data coming from the
server.</p>

<p>Here, we will use <a href="http://jinja.pocoo.org/docs/2.10/">jinja2</a> to
generate our XML and java files. First, define the template using jinja
templating language. Quick way is just to define it as a string in the
python file but it can also be read from file, which is better practice
when the templates are getting bigger and more numerous.</p>

<pre><code class="language-{.python}">XML_TEMPLATE = """&lt;root&gt;
    &lt;value1&gt;&lt;/value1&gt;
    &lt;value2&gt;&lt;/value2&gt;&gt;
&lt;/root&gt;
"""
</code></pre>

<p>Notice the curly brackets? Jinja will replace what’s inside by whatever
objects we pass. Object should have variables ‘value1’ and ‘value2’ to
work.</p>

<p>The next snippet will print this template with a test case object.</p>

<pre><code class="language-{.python}">from jinja2 import Template

if __name__ == "__name__":
    template = Template(XML_TEMPLATE)
    test_case = TestCase('name', 'path', 'value1', 'value2')
    print(template.render(test_case=test_case)
</code></pre>

<p>We insert the test~case~ variable in the template by passing it as a
keyword argument of the render method of jinja2.Template. This will
print:</p>

<pre><code class="language-{.xml}">&lt;root&gt;
    &lt;value1&gt;value1&lt;/value1&gt;
    &lt;value2&gt;value2&lt;/value2&gt;&gt;
&lt;/root&gt;
</code></pre>

<p>Creating the template for the java test class can be done in a similar
fashion. Here, we will leverage the for loop of jinja.</p>

<pre><code class="language-{.python}">JAVA_TEMPLATE = """
package com.core.validator;

import static org.junit.Assert.*;

public class XmlInputSuperbEnterpriseValidatorTest {

    
}

"""
</code></pre>

<p>The variable to insert in the template is test~cases~. It should be an
iterable as we use it in the for loop. Here how to generate 1000 test
cases with the java class to test them.</p>

<pre><code class="language-{.python}">from jinja2 import Template

if __name__ == "__name__":
    java_template = Template(JAVA_TEMPLATE)
    xml_template = Template(XML_TEMPLATE)

    path_out = "/somewhere/you/want/"
    test_cases = [TestCase("{}_test".format(i),
                           path_out,
                           i,
                           i+1) for i in range(0, 1000)]
    # Create the java file
    with open(path_out + 'XmlInputSuperbEnterpriseValidatorTest.java', 'w') as f:
        f.write(java_template.render(test_cases=test_cases)

    # Create the xml files
    for test_case in test_cases:
        with open(path_out + test_case.path + test_case.name, 'w') as f:
            f.write(xml_template.render(test_case=test_case))
</code></pre>

<p>Instead of printing the rendered templates to the console, we will just
write them to a file.</p>

<h3 id="glue-everything-together">Glue everything together</h3>

<p>We have a way to represent our tests, we have a way to print our tests
to file, we just need to have a way to read our test specification and
convert it to a TestCase object.</p>

<p>Our input file first line is the value1, and the second line is the
value2. To avoid cluttering the blog post, I will assume the file is
always correct and has as many elements in the first line than in the
second line.</p>

<pre><code class="language-{.python}">with open('test_specification') as f:
    test_input_values = [x.rstrip().split(',') for x in f.readlines()]
values1 = test_input_values[0]
values2 = test_input_values[1]
</code></pre>

<p>Then you can combine these value the way you want to create your test
cases.</p>

<p>Using zip:</p>

<pre><code class="language-{.python}">test_cases = [TestCase('{}_test'.format(nb),
                       path_out,
                       value1,
                       value2) for nb, (value1, value2) in enumerate(zip(values1, values2))]
</code></pre>

<p>zip will create a generator from many iterables. The ith element of a
zip object is a tuple containing the ith elements of each of the input
iterables. For example,</p>

<pre><code class="language-{.python}">for a, b in zip([1, 2], [3, 4]):
    print("{} - {}".format(a, b))
</code></pre>

<p>Will print “1 - 2” and “3 - 4”.</p>

<p>zip is combined with enumerate. Enumerate is also very simple. It takes
an iterator. The ith element of enumerate is (i, ith element of input
iterator).</p>

<pre><code class="language-{.python}">for index, el in enumerate(['a','b']):
    print("Index {}: {}".format(index, el))
</code></pre>

<p>Will print “Index 0: a” and “Index 1: b”. Notice that when combining zip
with enumerate, you need to add brackets when unpacking the values. Not
using brackets would throw a ValueError (not enough values to unpack
(expected 3, got 2). The reason is that enumerate is sending a tuple of
size two.</p>

<p>Another way to combine test cases is to use itertools.product. Product
will yield all combinaisons possible of multiple iterables.</p>

<pre><code class="language-{.python}">from itertools import product

for a, b in product([1, 2], ['a', 'b', 'c']):
    print("{} - {}".format(a, b))
</code></pre>

<p>will print: 1 - a 1 - b 1 - c 2 - a 2 - b 2 - c</p>

<p>You can use product to test all the possible combinaisons of your input
values.</p>

<pre><code class="language-{.python}">from itertools import product

test_cases = [TestCase('{}_test'.format(nb),
                       path_out,
                       value1,
                       value2) for nb, (value1, value2) in enumerate(product(values1, values2))]
</code></pre>

<p>There is so much to say about generators, iterators.</p>

<h1 id="generalizing-this-approach">Generalizing this approach</h1>

<p>In this post, we learned about how to use python and jinja2 to automate
test creation. Instead of spending your precious time writing
boilerplate code, you can just focus on what you want to test.</p>

<p>This is a simple example, the concept of automation is very powerful and
helps tremendously in every day life. Even if your activities do not
imply coding, there must be some repetitive task that can be automize.
For example, sending the same mail to each mail address in an excel
spreadsheet. This can be automized (see pandas to read from excel file).</p>

<p>If you’re interested in the subject, have a look at <a href="https://automatetheboringstuff.com/">automate the boring
stuff with Python.</a></p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2018/04/26/fantasy-novel-series-and-the-wait.html">
        Fantasy novel series, and the Wait
      </a>
    </h1>

    <span class="post-date">26 Apr 2018</span>

    <p>I’ve always been an avid reader of long fantasy novel series. As a kid,
I used to read Lord of the ring, Harry Potter (does it count? Yes it
does!) and basically everything I could put my hand on.</p>

<p>More recently I’ve been a huge fan of the work of Brandon Sanderson. For
those who don’t know, Sandersonis the epic fantasy writer. He builds
entire world in different series of books that are somewhat connected in
the grander scheme: <a href="https://brandonsanderson.com/">Sanderson website</a></p>

<p>So yes, I really love epic Fantasy. But amazing book series come with a
big caveat: the Wait. As opposed to the Thrill while reading, the Wait
is the excruciable period from when I finish a book until the next one
is released. Let’s take a few example: The Stormlight Archive by
Sanderson is a novel series which contains 3 books at the moment:</p>

<ul>
  <li>The Way of Kings, published August 31, 2010</li>
  <li>Words of Radiance, published March 4, 2014</li>
  <li>Oathbringer, published November 14, 2017</li>
</ul>

<p>I’ve been in a state of passive suffering for at least 7 years.</p>

<p>Another great series of novel is <em>The Kingkiller Chronicle</em> by Patrick
Rothfuss. Here, the last book has been published 7 years ago!</p>

<p>And also, Game of Thrones people?</p>

<p>To be clear, I am very grateful to the authors out there that are
publishing these fantastic books. But how to satisfy the Wait? I’ve
found two ways some far:</p>

<ol>
  <li>Read more novels. This has the benefit of making me forget a bit
about the previous book I read, but it might add more series to the
wait list.</li>
  <li>Read novel series that have already ended. That way no more wait.
Just a feeling of emptiness at the end.</li>
</ol>


  </div>
  
</div>

<div class="pagination">
  
    <a class="pagination-item older" href="/page2">Older</a>
  
  
    <span class="pagination-item newer">Newer</span>
  
</div>
    </div>

  </body>
</html>
