<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Snoozetime's webpage (Posts about 2d)</title><link>http://snoozetime.github.io/</link><description></description><atom:link href="http://snoozetime.github.io/categories/2d.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents Â© 2018 &lt;a href="mailto:benoit.eudier@gmail.com"&gt;Snoozetime&lt;/a&gt; </copyright><lastBuildDate>Fri, 09 Nov 2018 08:57:38 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Bezier curve in Unity: Bounding boxes</title><link>http://snoozetime.github.io/posts/slug/</link><dc:creator>Snoozetime</dc:creator><description>&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="http://snoozetime.github.io/images/micromachine.jpg" alt="micromachine.jpg"&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
Instead of the common FPS/RPG/Platformer, for some reason I decide to create a clone of the old micromachine,
in particular the elimination mode when players are eliminated when they are too far away from the first player.
&lt;/p&gt;

&lt;p&gt;
As the game was creating itself in my head, I stumbled against a mathematical obstacle in the first week
of prototyping. How to determine which player is the first? How to determinate what path the AI should
follow.
&lt;/p&gt;

&lt;p&gt;
It turns out that part of the answer is to represent tracks as a curve, and Bezier curves are used in a bunch of
applications from photoshop to font creation. To find out what player is first, I would just have
to calculate the position of all pilots on the tracks.
&lt;/p&gt;

&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;Some reading before getting started&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
This article will be introducing a bit a linear algebra. In particular, we will apply translation and
rotation to our vectors. Also, we need to find the roots of a quadratic equation. The maths are not
too complicated but feel free to read the following links beforehand:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Quadratic_equation"&gt;Wikipedia article on finding the roots of a quadratic formula&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="http://planning.cs.uiuc.edu/node97.html"&gt;Description of translation, rotation and their combinaison&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
This article builds on an existing article which can be found here: &lt;a href="https://catlikecoding.com/unity/tutorials/curves-and-splines/"&gt;https://catlikecoding.com/unity/tutorials/curves-and-splines/&lt;/a&gt;
It shows how to implement a Bezier curve in Unity, showing at the same time how editor scripts work.
&lt;/p&gt;

&lt;p&gt;
The last resource is an ebook called "A primer on Bezier". It can be found &lt;a href="https://pomax.github.io/bezierinfo/"&gt;here.&lt;/a&gt;
This ebook contains all you need to know about Bezier curves, theory and pseudocode included.
&lt;/p&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="http://snoozetime.github.io/images/bezier_initial.png" alt="bezier_initial.png"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-2" class="outline-2"&gt;
&lt;h2 id="sec-2"&gt;Bounding box&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
Bounding box are useful. In my use case, I want to find the closest point to the spline so bounding boxes
will help determine what bezier curve I should select to do the calculation!
&lt;/p&gt;

&lt;p&gt;
The way to find the bounding box is to get the minimim/maximum along the x and y axis and create the boxes
from (x&lt;sub&gt;min&lt;/sub&gt;, y&lt;sub&gt;min&lt;/sub&gt;), (x&lt;sub&gt;min&lt;/sub&gt;, y&lt;sub&gt;max&lt;/sub&gt;), (x&lt;sub&gt;max&lt;/sub&gt;, y&lt;sub&gt;min&lt;/sub&gt;), (x&lt;sub&gt;max&lt;/sub&gt;, y&lt;sub&gt;max&lt;/sub&gt;).
&lt;/p&gt;

&lt;p&gt;
However, this has the tendency to create large bounding boxes so we can get tighter boxes by aligning them
along our curve. (&lt;a href="https://pomax.github.io/bezierinfo/#boundingbox"&gt;Part 17 - Bounding box&lt;/a&gt;)
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-2-1" class="outline-3"&gt;
&lt;h3 id="sec-2-1"&gt;Beforehand, define the curve&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-1"&gt;
&lt;p&gt;
Curve is such as
&lt;/p&gt;
\begin{equation}
B(t) = (1-t)^3P_0 + 3(1-t)^2tP_1 + 3(1-t)t^2P_2 + t^3P_3
\end{equation}

&lt;p&gt;
where \(P_0, P_1, P_2, P_3\) are the control points of the curve, in global coordinates.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-2-2" class="outline-3"&gt;
&lt;h3 id="sec-2-2"&gt;Align the curve on an axis.&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-2"&gt;
&lt;p&gt;
To align the curve, we first need to apply a translation T to the first point of the curve in order to place it
on the origin (0, 0). We have \(T = -P_0\).
&lt;/p&gt;

zsh:1: command not found: pygmentize

&lt;p&gt;
Then, we need to apply the rotation so that \(P_3\) is on the x-axis. Given x and y the coordinates of \(P_3\), x' and y'
the coordinates after rotation \(\theta\), we have the equations:
&lt;/p&gt;

\begin{equation}
x' = xcos(theta) - ysin(theta)

y' = ycos(theta) + x sin(theta)
\end{equation}

&lt;p&gt;
&lt;a href="https://www.siggraph.org/education/materials/HyperGraph/modeling/mod_tran/2drota.htm"&gt;Don't take my word for granted :)&lt;/a&gt;
&lt;/p&gt;

zsh:1: command not found: pygmentize

&lt;p&gt;
We find theta such as \(y' = 0\).
&lt;/p&gt;
\begin{equation}
\theta = atan(-y/x)
\end{equation}

zsh:1: command not found: pygmentize

&lt;p&gt;
Just for fun, let's draw the Bezier curve after rotation.
&lt;/p&gt;

zsh:1: command not found: pygmentize

&lt;p&gt;
When adding the aligned curve to the editor script, we get the following.
&lt;/p&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="http://snoozetime.github.io/images/aligned_bezier.png" alt="aligned_bezier.png"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-2-3" class="outline-3"&gt;
&lt;h3 id="sec-2-3"&gt;Find the bounding box for the aligned curve&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-3"&gt;
&lt;p&gt;
Once we have our aligned curve, we need to find its bounding box. To do so, we need to calculate the roots of the
curve for x and y in order to get the minimum and maximum on the axis for t between 0 and 1.
&lt;/p&gt;

&lt;p&gt;
To get an idea about why we want the minimum and maximum of a curve, please refer to my amazing drawing.
&lt;img src="http://snoozetime.github.io/images/bounding_box.png" alt="bounding_box.png"&gt;
&lt;/p&gt;

&lt;p&gt;
In this piece of art, the maximum and minimum of y are located on the curve. For x however, only the
minimum x is located on the curve. The maximum is one of our control point. This is why we absolutely
have to include the first and last control points when we want to find the minimum and maximum on each
axis.
&lt;/p&gt;

&lt;p&gt;
For a quadratic or cubic Bezier curve, it is very easy to find the minimum and maximum for each axis.
The way to do it is to calculate the derivate of the curve, and find the t values for which this
derivative is 0. These values are called the roots of the curve for the x or y axis. The Wikipedia
article at the top of the blog article explains it more deeply.
&lt;/p&gt;

&lt;p&gt;
After deriving the Bezier equation and simplifying it a bit, we obtain:
&lt;/p&gt;
\begin{equation}
3 (-x_{p_0} + 3x_{p_1} - 3x_{p_2} + x_{p_3})t^2 + 6(x_{p_0} - 2x_{p_1} + x_{p_2})t + 3(x_{p_1} - x_{p_0}) = 0
\end{equation}

&lt;p&gt;
Where \(x_{p_i}\) is the x coordinate of the point i. There is the same equation for y. Now that
we have reduce our equation to a simple quadratic equation, the solution is textbook.
&lt;/p&gt;

\begin{equation}
a = 3(-x_{p_0} + 3x_{p_1} - 3x_{p_2} + x_{p_3})
\end{equation}

\begin{equation}
b = 6(x_{p_0} - 2x_{p_1} + x_{p_2})
\end{equation}

\begin{equation}
c = 3(x_{p_1} - x_{p_0})
\end{equation}

\begin{equation}
\Delta = b^2 - 4 ac
\end{equation}

&lt;p&gt;
\(\Delta\) (Delta) is the discriminant. We can find imaginary roots (that cannot be represented in our
2D space) when delta is negative, so here we are just interested about the real roots, meaning when
\(\Delta &amp;gt;= 0\).
&lt;/p&gt;

&lt;p&gt;
The two roots (which can be only one is the discriminant is 0) for the axis x are:
&lt;/p&gt;

\begin{equation}
t_1 = \frac{-b - \sqrt{\Delta}}{4ac}
\end{equation}

\begin{equation}
t_2 = \frac{-b + \sqrt{\Delta}}{4ac}
\end{equation}

&lt;p&gt;
Notice that when \(\Delta\) is 0, \(t_1\) and \(t_2\) are the same. For our Bezier curve, we only care about
parameter between 0 and 1 so the roots might not be usable. In C#, there is not much complexity. Just
write down the last equations and filter the values.
&lt;/p&gt;

zsh:1: command not found: pygmentize
&lt;p&gt;
(You can even refactor this to do the calculation once! When reading back this code I noticed that
I was a bit lazy here).
&lt;/p&gt;


&lt;p&gt;
Now, our minimum and maximum along x and y would be one of the point that has a parameter t, where t
is either a root, 0 or 1.
&lt;/p&gt;

zsh:1: command not found: pygmentize

&lt;p&gt;
We have our \(x_min\), \(x_max\), \(y_min\), \(y_max\). This is all we need for drawing the bounding box.
&lt;/p&gt;



&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="http://snoozetime.github.io/images/bounding_box_aligned.png" alt="bounding_box_aligned.png"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;



&lt;div id="outline-container-sec-2-4" class="outline-3"&gt;
&lt;h3 id="sec-2-4"&gt;Rotate the box back&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-4"&gt;
&lt;p&gt;
Almost there! At this point, we have the bounding box of the aligned curve. To get the aligned curve,
we applied two transformations to our Bezier curve: first a translation, then a rotation. To get back
to the original curve, you can simply do the inverse! First, rotate the aligned curve by the opposite
of the first rotation (\(-\theta\)), then translate it by the opposite of the first translation (\(-P_0\)).
&lt;/p&gt;

&lt;p&gt;
We can do the same with the bounding box, and it should fit our original Bezier curve!
&lt;/p&gt;

&lt;p&gt;
With the previous minima and maxima:
&lt;/p&gt;
zsh:1: command not found: pygmentize

&lt;p&gt;
Which gives us, at last:
&lt;/p&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="http://snoozetime.github.io/images/bounding_box_final.png" alt="bounding_box_final.png"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;



&lt;div id="outline-container-sec-3" class="outline-2"&gt;
&lt;h2 id="sec-3"&gt;What's next?&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
All this to find the bounding boxes of each curve in our Bezier spline! While it looks like a lot of work,
these bounding boxes are really going to help us find the projection of a point on the spline.
&lt;/p&gt;

&lt;p&gt;
Instead of having to consider all the spline, now we can just reduce the problem to a list of Bezier curves.
Calculating distance to a box is pretty simple, so we just need to find the closest boxes to our point and
for each curve, finding the closest point. This will be done by an iterative approach (mathematical approach
is out of the question here - spoiler alert), so keep tuned for the next article.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>2d</category><category>bezier</category><category>gamedev</category><category>mathjax</category><category>unity</category><guid>http://snoozetime.github.io/posts/slug/</guid><pubDate>Mon, 21 May 2018 15:00:00 GMT</pubDate></item></channel></rss>